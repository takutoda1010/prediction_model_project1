---
title: "06_Model_evaluator"
author: "Takuto Yoshida"
date: "2025-11-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
################################################################################
# 06_model_evaluator.R - ãƒ¢ãƒ‡ãƒ«è©•ä¾¡å‡¦ç†
# 
# Description: 
#   ãƒ¢ãƒ‡ãƒ«æ€§èƒ½ã®åŒ…æ‹¬çš„è©•ä¾¡
#   C-index, æ™‚é–“ä¾å­˜AUC, ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³, DCA, Brier Score
#   ç«¶åˆãƒªã‚¹ã‚¯è©•ä¾¡
#
# Author: Takuto Yoshida
# Date: 2024-11-07
################################################################################

# ========================================================================
# 1. äºˆæ¸¬å€¤ã®è¨ˆç®—
# ========================================================================

#' ãƒ¢ãƒ‡ãƒ«ã‹ã‚‰äºˆæ¸¬å€¤ã‚’å–å¾—
#' @param model ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
#' @param newdata äºˆæ¸¬ç”¨ãƒ‡ãƒ¼ã‚¿
#' @param time_point äºˆæ¸¬æ™‚ç‚¹ï¼ˆæœˆï¼‰
#' @return äºˆæ¸¬ç¢ºç‡
get_predictions <- function(model, newdata, time_point = 24) {
  
  # ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—ã®åˆ¤å®š
  model_class <- class(model)[1]
  
  if (model_class == "coxph") {
    # é€šå¸¸ã®Coxãƒ¢ãƒ‡ãƒ«
    
    # ç·šå½¢äºˆæ¸¬å­
    lp <- predict(model, newdata = newdata, type = "lp")
    
    # ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ç”Ÿå­˜é–¢æ•°
    baseline <- survival::survfit(model, newdata = newdata[1, ])
    
    # æŒ‡å®šæ™‚ç‚¹ã«æœ€ã‚‚è¿‘ã„æ™‚é–“ã‚’è¦‹ã¤ã‘ã‚‹
    time_idx <- which.min(abs(baseline$time - time_point))
    baseline_surv <- baseline$surv[time_idx]
    
    # äºˆæ¸¬ç¢ºç‡ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆç¢ºç‡ï¼‰
    pred_prob <- 1 - baseline_surv^exp(lp)
    
  } else if (model_class == "lasso_cox") {
    # LASSOãƒ¢ãƒ‡ãƒ«
    
    # ãƒ‡ãƒ¼ã‚¿è¡Œåˆ—ã®æº–å‚™
    X_new <- model.matrix(~ . - 1, 
                         data = newdata[, colnames(model$X), drop = FALSE])
    
    # ç·šå½¢äºˆæ¸¬å­
    lp <- predict(model$glmnet_model, newx = X_new, s = model$lambda_min, type = "link")
    
    # ç°¡æ˜“çš„ãªç¢ºç‡å¤‰æ›ï¼ˆãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ãƒã‚¶ãƒ¼ãƒ‰ã‚’ä»®å®šï¼‰
    pred_prob <- 1 - exp(-exp(lp) * time_point / 12)  # å˜ç´”åŒ–
    
  } else if (model_class == "univariate_cox") {
    # å˜å¤‰é‡ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãƒ¢ãƒ‡ãƒ«
    
    if (!is.null(model$model)) {
      lp <- predict(model$model, newdata = newdata, type = "lp")
      
      # ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ç”Ÿå­˜é–¢æ•°
      baseline <- survival::survfit(model$model, newdata = newdata[1, ])
      time_idx <- which.min(abs(baseline$time - time_point))
      baseline_surv <- baseline$surv[time_idx]
      
      pred_prob <- 1 - baseline_surv^exp(lp)
    } else {
      pred_prob <- rep(NA, nrow(newdata))
    }
    
  } else if (model_class == "rfe_cox") {
    # RFEãƒ¢ãƒ‡ãƒ«
    
    if (!is.null(model$model)) {
      lp <- predict(model$model, newdata = newdata, type = "lp")
      
      baseline <- survival::survfit(model$model, newdata = newdata[1, ])
      time_idx <- which.min(abs(baseline$time - time_point))
      baseline_surv <- baseline$surv[time_idx]
      
      pred_prob <- 1 - baseline_surv^exp(lp)
    } else {
      pred_prob <- rep(NA, nrow(newdata))
    }
    
  } else {
    warning(sprintf("Unknown model class: %s", model_class))
    pred_prob <- rep(NA, nrow(newdata))
  }
  
  return(as.numeric(pred_prob))
}

# ========================================================================
# 2. C-indexè¨ˆç®—
# ========================================================================

#' C-indexã‚’è¨ˆç®—
#' @param model ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
#' @param data è©•ä¾¡ç”¨ãƒ‡ãƒ¼ã‚¿ï¼ˆsurv_objåˆ—ã‚’å«ã‚€ï¼‰
#' @param newdata äºˆæ¸¬ç”¨ãƒ‡ãƒ¼ã‚¿ï¼ˆNULLæ™‚ã¯dataã‚’ä½¿ç”¨ï¼‰
#' @return C-indexå€¤ã¨ä¿¡é ¼åŒºé–“
calculate_c_index <- function(model, data, newdata = NULL) {
  
  if (is.null(newdata)) {
    newdata <- data
  }
  
  # äºˆæ¸¬å€¤ã®å–å¾—
  if (inherits(model, "coxph")) {
    # Coxãƒ¢ãƒ‡ãƒ«ã®å ´åˆ
    pred <- predict(model, newdata = newdata, type = "risk")
    
    # concordanceé–¢æ•°ã‚’ä½¿ç”¨
    c_result <- survival::concordance(
      data$surv_obj ~ pred,
      reverse = TRUE
    )
    
    c_index <- c_result$concordance
    se <- sqrt(c_result$var)
    
  } else if (inherits(model, "lasso_cox")) {
    # LASSOãƒ¢ãƒ‡ãƒ«
    X_new <- model.matrix(~ . - 1, 
                         data = newdata[, colnames(model$X), drop = FALSE])
    pred <- predict(model$glmnet_model, newx = X_new, 
                   s = model$lambda_min, type = "link")[, 1]
    
    c_result <- survival::concordance(
      data$surv_obj ~ pred,
      reverse = TRUE
    )
    
    c_index <- c_result$concordance
    se <- sqrt(c_result$var)
    
  } else {
    # ãã®ä»–ã®ãƒ¢ãƒ‡ãƒ«
    pred <- get_predictions(model, newdata)
    
    if (all(is.na(pred))) {
      return(list(c_index = NA, lower = NA, upper = NA, se = NA))
    }
    
    c_result <- survival::concordance(
      data$surv_obj ~ pred,
      reverse = FALSE
    )
    
    c_index <- c_result$concordance
    se <- sqrt(c_result$var)
  }
  
  # 95%ä¿¡é ¼åŒºé–“
  lower <- c_index - 1.96 * se
  upper <- c_index + 1.96 * se
  
  return(list(
    c_index = c_index,
    lower = max(0, lower),
    upper = min(1, upper),
    se = se
  ))
}

# ========================================================================
# 3. æ™‚é–“ä¾å­˜AUC
# ========================================================================

#' æ™‚é–“ä¾å­˜AUCã‚’è¨ˆç®—
#' @param model ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
#' @param data è©•ä¾¡ç”¨ãƒ‡ãƒ¼ã‚¿
#' @param times è©•ä¾¡æ™‚ç‚¹ã®ãƒ™ã‚¯ãƒˆãƒ«
#' @return æ™‚é–“ä¾å­˜AUC
calculate_time_dependent_auc <- function(model, data, times = c(6, 12, 18, 24)) {
  
  if (!requireNamespace("timeROC", quietly = TRUE)) {
    warning("timeROC package not available")
    return(NULL)
  }
  
  # äºˆæ¸¬å€¤ã®å–å¾—ï¼ˆãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢ï¼‰
  if (inherits(model, "coxph")) {
    marker <- predict(model, newdata = data, type = "lp")
  } else if (inherits(model, "lasso_cox")) {
    X_new <- model.matrix(~ . - 1, 
                         data = data[, colnames(model$X), drop = FALSE])
    marker <- predict(model$glmnet_model, newx = X_new, 
                     s = model$lambda_min, type = "link")[, 1]
  } else {
    # äºˆæ¸¬ç¢ºç‡ã‚’ä½¿ç”¨
    marker <- get_predictions(model, data, time_point = max(times))
    if (all(is.na(marker))) {
      return(NULL)
    }
  }
  
  # timeROCã®å®Ÿè¡Œ
  roc_result <- timeROC::timeROC(
    T = data$time2y,
    delta = as.numeric(data$recur_2y),
    marker = marker,
    cause = 1,
    weighting = "marginal",
    times = times,
    iid = TRUE
  )
  
  # çµæœã®æ•´ç†
  auc_df <- data.frame(
    time = times,
    AUC = roc_result$AUC,
    AUC_lower = roc_result$AUC - 1.96 * roc_result$inference$vect_sd_1,
    AUC_upper = roc_result$AUC + 1.96 * roc_result$inference$vect_sd_1
  )
  
  auc_df$AUC_lower <- pmax(0, auc_df$AUC_lower)
  auc_df$AUC_upper <- pmin(1, auc_df$AUC_upper)
  
  return(list(
    auc_table = auc_df,
    roc_object = roc_result
  ))
}

# ========================================================================
# 4. ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è©•ä¾¡
# ========================================================================

#' ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è©•ä¾¡
#' @param model ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
#' @param data è©•ä¾¡ç”¨ãƒ‡ãƒ¼ã‚¿
#' @param n_groups ãƒ‡ã‚·ãƒ«åˆ†å‰²æ•°
#' @param time_point è©•ä¾¡æ™‚ç‚¹
#' @return ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµ±è¨ˆé‡
assess_calibration <- function(model, data, n_groups = 10, time_point = 24) {
  
  # äºˆæ¸¬ç¢ºç‡
  pred_prob <- get_predictions(model, data, time_point)
  
  if (all(is.na(pred_prob))) {
    return(list(
      slope = NA,
      intercept = NA,
      groups = NULL
    ))
  }
  
  # ãƒ‡ã‚·ãƒ«åˆ†å‰²
  pred_groups <- cut(pred_prob, 
                    breaks = quantile(pred_prob, probs = seq(0, 1, 1/n_groups), na.rm = TRUE),
                    include.lowest = TRUE,
                    labels = FALSE)
  
  # å„ã‚°ãƒ«ãƒ¼ãƒ—ã®è¦³å¯Ÿãƒ»æœŸå¾…ã‚¤ãƒ™ãƒ³ãƒˆç‡
  calibration_data <- data.frame()
  
  for (g in 1:n_groups) {
    idx <- which(pred_groups == g)
    if (length(idx) > 0) {
      # Kaplan-Meieræ¨å®š
      km_fit <- survival::survfit(
        survival::Surv(time2y, recur_2y) ~ 1, 
        data = data[idx, ]
      )
      
      # æŒ‡å®šæ™‚ç‚¹ã§ã®è¦³å¯Ÿã‚¤ãƒ™ãƒ³ãƒˆç‡
      time_idx <- which.min(abs(km_fit$time - time_point))
      if (length(time_idx) > 0) {
        observed <- 1 - km_fit$surv[time_idx]
      } else {
        observed <- NA
      }
      
      # æœŸå¾…ã‚¤ãƒ™ãƒ³ãƒˆç‡ï¼ˆäºˆæ¸¬å€¤ã®å¹³å‡ï¼‰
      expected <- mean(pred_prob[idx], na.rm = TRUE)
      
      calibration_data <- rbind(calibration_data, data.frame(
        group = g,
        n = length(idx),
        expected = expected,
        observed = observed,
        pred_mean = expected,
        pred_min = min(pred_prob[idx], na.rm = TRUE),
        pred_max = max(pred_prob[idx], na.rm = TRUE)
      ))
    }
  }
  
  # Calibration slope & intercept
  if (nrow(calibration_data) > 2 && !any(is.na(calibration_data$observed))) {
    cal_model <- lm(observed ~ expected, data = calibration_data, weights = n)
    slope <- coef(cal_model)["expected"]
    intercept <- coef(cal_model)["(Intercept)"]
  } else {
    slope <- NA
    intercept <- NA
  }
  
  return(list(
    slope = slope,
    intercept = intercept,
    groups = calibration_data
  ))
}

# ========================================================================
# 5. Decision Curve Analysis (DCA)
# ========================================================================

#' Decision Curve Analysis
#' @param model ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
#' @param data è©•ä¾¡ç”¨ãƒ‡ãƒ¼ã‚¿
#' @param thresholds é–¾å€¤ã®ç¯„å›²
#' @param time_point è©•ä¾¡æ™‚ç‚¹
#' @return DCAçµæœ
perform_dca <- function(model, data, 
                       thresholds = seq(0.01, 0.50, by = 0.01),
                       time_point = 24) {
  
  # äºˆæ¸¬ç¢ºç‡
  pred_prob <- get_predictions(model, data, time_point)
  
  if (all(is.na(pred_prob))) {
    return(NULL)
  }
  
  # å®Ÿéš›ã®ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ™‚é–“ã‚’è€ƒæ…®ï¼‰
  event_occurred <- (data$recur_2y == TRUE) & (data$time2y <= time_point)
  
  # DCAè¨ˆç®—
  dca_results <- data.frame(
    threshold = thresholds,
    net_benefit_model = numeric(length(thresholds)),
    net_benefit_all = numeric(length(thresholds)),
    net_benefit_none = 0
  )
  
  n_total <- nrow(data)
  
  for (i in seq_along(thresholds)) {
    thresh <- thresholds[i]
    
    # ãƒ¢ãƒ‡ãƒ«ã«ã‚ˆã‚‹ä»‹å…¥
    treat_model <- pred_prob >= thresh
    tp_model <- sum(treat_model & event_occurred, na.rm = TRUE)
    fp_model <- sum(treat_model & !event_occurred, na.rm = TRUE)
    
    # Net benefitè¨ˆç®—
    net_benefit_model <- (tp_model / n_total) - 
                        (fp_model / n_total) * (thresh / (1 - thresh))
    
    # å…¨å“¡æ²»ç™‚
    tp_all <- sum(event_occurred, na.rm = TRUE)
    fp_all <- sum(!event_occurred, na.rm = TRUE)
    net_benefit_all <- (tp_all / n_total) - 
                      (fp_all / n_total) * (thresh / (1 - thresh))
    
    dca_results$net_benefit_model[i] <- net_benefit_model
    dca_results$net_benefit_all[i] <- net_benefit_all
  }
  
  return(dca_results)
}

# ========================================================================
# 6. Brier Score
# ========================================================================

#' Brier Scoreã‚’è¨ˆç®—
#' @param model ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
#' @param data è©•ä¾¡ç”¨ãƒ‡ãƒ¼ã‚¿
#' @param time_point è©•ä¾¡æ™‚ç‚¹
#' @return Brier Score
calculate_brier_score <- function(model, data, time_point = 24) {
  
  # äºˆæ¸¬ç¢ºç‡
  pred_prob <- get_predictions(model, data, time_point)
  
  if (all(is.na(pred_prob))) {
    return(list(brier_score = NA, scaled_brier = NA))
  }
  
  # å®Ÿéš›ã®ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ™‚é–“ã‚’è€ƒæ…®ï¼‰
  event_occurred <- (data$recur_2y == TRUE) & (data$time2y <= time_point)
  
  # Brier Score
  brier_score <- mean((pred_prob - as.numeric(event_occurred))^2, na.rm = TRUE)
  
  # Scaled Brier Scoreï¼ˆå‚ç…§ï¼šã‚¤ãƒ™ãƒ³ãƒˆç‡ï¼‰
  event_rate <- mean(event_occurred, na.rm = TRUE)
  max_brier <- event_rate * (1 - event_rate)
  scaled_brier <- 1 - (brier_score / max_brier)
  
  return(list(
    brier_score = brier_score,
    scaled_brier = scaled_brier,
    event_rate = event_rate
  ))
}

# ========================================================================
# 7. çµ±åˆè©•ä¾¡é–¢æ•°
# ========================================================================

#' ãƒ¢ãƒ‡ãƒ«ã®åŒ…æ‹¬çš„è©•ä¾¡
#' @param model ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
#' @param train_data è¨“ç·´ãƒ‡ãƒ¼ã‚¿
#' @param val_data æ¤œè¨¼ãƒ‡ãƒ¼ã‚¿
#' @param test_data ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
#' @param config è¨­å®šãƒªã‚¹ãƒˆ
#' @return è©•ä¾¡çµæœã®ãƒªã‚¹ãƒˆ
evaluate_model_comprehensive <- function(model, 
                                        train_data, 
                                        val_data = NULL, 
                                        test_data = NULL,
                                        config = NULL) {
  
  # è©•ä¾¡æ™‚ç‚¹ã®å–å¾—
  if (!is.null(config) && !is.null(config$evaluation$time_points)) {
    time_points <- config$evaluation$time_points
  } else {
    time_points <- c(6, 12, 18, 24)
  }
  
  primary_time <- ifelse(!is.null(config$evaluation$primary_time_point),
                        config$evaluation$primary_time_point, 24)
  
  # ãƒ‡ãƒ¼ã‚¿æº–å‚™
  datasets <- list(train = train_data)
  if (!is.null(val_data)) datasets$val <- val_data
  if (!is.null(test_data)) datasets$test <- test_data
  
  # çµæœæ ¼ç´ç”¨
  results <- list()
  
  for (set_name in names(datasets)) {
    message(sprintf("\n  Evaluating on %s set...", set_name))
    
    data <- datasets[[set_name]]
    
    # surv_objãŒãªã„å ´åˆã¯ä½œæˆ
    if (!"surv_obj" %in% names(data)) {
      data$surv_obj <- survival::Surv(
        time = data$time2y,
        event = as.numeric(data$recur_2y)
      )
    }
    
    # C-index
    c_result <- calculate_c_index(model, data)
    message(sprintf("    C-index: %.3f (95%% CI: %.3f-%.3f)", 
                   c_result$c_index, c_result$lower, c_result$upper))
    
    # æ™‚é–“ä¾å­˜AUC
    auc_result <- calculate_time_dependent_auc(model, data, time_points)
    if (!is.null(auc_result)) {
      auc_primary <- auc_result$auc_table[auc_result$auc_table$time == primary_time, "AUC"]
      message(sprintf("    AUC at %d months: %.3f", primary_time, auc_primary))
    }
    
    # ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    cal_result <- assess_calibration(model, data, time_point = primary_time)
    if (!is.na(cal_result$slope)) {
      message(sprintf("    Calibration slope: %.3f, intercept: %.3f", 
                     cal_result$slope, cal_result$intercept))
    }
    
    # Brier Score
    brier_result <- calculate_brier_score(model, data, time_point = primary_time)
    if (!is.na(brier_result$brier_score)) {
      message(sprintf("    Brier score: %.3f (scaled: %.3f)", 
                     brier_result$brier_score, brier_result$scaled_brier))
    }
    
    # DCAï¼ˆãƒ†ã‚¹ãƒˆã‚»ãƒƒãƒˆã®ã¿ï¼‰
    if (set_name == "test") {
      dca_result <- perform_dca(model, data, time_point = primary_time)
    } else {
      dca_result <- NULL
    }
    
    # çµæœã‚’ä¿å­˜
    results[[set_name]] <- list(
      c_index = c_result,
      time_auc = auc_result,
      calibration = cal_result,
      brier = brier_result,
      dca = dca_result
    )
  }
  
  return(results)
}

# ========================================================================
# 8. å…¨ãƒ¢ãƒ‡ãƒ«è©•ä¾¡
# ========================================================================

#' å…¨ãƒ¢ãƒ‡ãƒ«ã‚’è©•ä¾¡
#' @param models ãƒ¢ãƒ‡ãƒ«ãƒªã‚¹ãƒˆ
#' @param split_data åˆ†å‰²ãƒ‡ãƒ¼ã‚¿
#' @param config è¨­å®šãƒªã‚¹ãƒˆ
#' @return è©•ä¾¡çµæœ
evaluate_all_models <- function(models, split_data, config = NULL) {
  
  message("\n========================================")
  message("Evaluating All Models")
  message("========================================")
  
  # ãƒ‡ãƒ¼ã‚¿æº–å‚™
  train_data <- prepare_model_data(split_data$train, config = config)
  val_data <- prepare_model_data(split_data$val, config = config)
  test_data <- prepare_model_data(split_data$test, config = config)
  
  # çµæœæ ¼ç´
  all_results <- list()
  summary_table <- data.frame()
  
  for (model_name in names(models)) {
    
    model <- models[[model_name]]
    
    if (!is.null(model)) {
      message(sprintf("\n--- Model: %s ---", model_name))
      
      tryCatch({
        # åŒ…æ‹¬çš„è©•ä¾¡
        eval_result <- evaluate_model_comprehensive(
          model,
          train_data,
          val_data,
          test_data,
          config
        )
        
        all_results[[model_name]] <- eval_result
        
        # ã‚µãƒãƒªãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ 
        summary_row <- data.frame(
          model = model_name,
          n_vars = attr(model, "n_vars"),
          c_index_train = eval_result$train$c_index$c_index,
          c_index_val = ifelse(!is.null(eval_result$val), 
                              eval_result$val$c_index$c_index, NA),
          c_index_test = ifelse(!is.null(eval_result$test), 
                               eval_result$test$c_index$c_index, NA),
          brier_test = ifelse(!is.null(eval_result$test), 
                             eval_result$test$brier$brier_score, NA)
        )
        
        summary_table <- rbind(summary_table, summary_row)
        
      }, error = function(e) {
        message(sprintf("  âŒ Error evaluating %s: %s", model_name, e$message))
        all_results[[model_name]] <- NULL
      })
    }
  }
  
  # ã‚µãƒãƒªãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’C-indexã§ã‚½ãƒ¼ãƒˆ
  if (nrow(summary_table) > 0) {
    summary_table <- summary_table[order(summary_table$c_index_test, decreasing = TRUE), ]
    rownames(summary_table) <- NULL
    
    message("\nğŸ“Š Model Performance Summary:")
    print(summary_table, digits = 3)
  }
  
  message("\nâœ… Model evaluation completed!")
  message("========================================\n")
  
  # çµæœã‚’è¿”ã™
  return(list(
    results = all_results,
    summary = summary_table,
    data = list(
      train = train_data,
      val = val_data,
      test = test_data
    )
  ))
}

# ========================================================================
# 9. è©•ä¾¡çµæœã®ä¿å­˜
# ========================================================================

#' è©•ä¾¡çµæœã‚’ä¿å­˜
#' @param evaluation_results è©•ä¾¡çµæœ
#' @param file_path ä¿å­˜å…ˆãƒ‘ã‚¹
#' @param format ä¿å­˜å½¢å¼ï¼ˆ"rds", "csv"ï¼‰
save_evaluation_results <- function(evaluation_results, 
                                   file_path, 
                                   format = "rds") {
  
  # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
  dir_path <- dirname(file_path)
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE, showWarnings = FALSE)
  }
  
  if (format == "rds") {
    saveRDS(evaluation_results, file = file_path)
    message(sprintf("  âœ“ Results saved to: %s", file_path))
    
  } else if (format == "csv") {
    # ã‚µãƒãƒªãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã¿CSVä¿å­˜
    write.csv(evaluation_results$summary, 
             file = file_path, 
             row.names = FALSE)
    message(sprintf("  âœ“ Summary saved to: %s", file_path))
  }
}

# ========================================================================
# 10. ãƒ¢ãƒ‡ãƒ«æ¯”è¼ƒ
# ========================================================================

#' ãƒ¢ãƒ‡ãƒ«ã®çµ±è¨ˆçš„æ¯”è¼ƒ
#' @param results è©•ä¾¡çµæœ
#' @param metric æ¯”è¼ƒæŒ‡æ¨™ï¼ˆ"c_index", "auc", "brier"ï¼‰
#' @param dataset ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆåï¼ˆ"test", "val"ï¼‰
#' @return æ¯”è¼ƒçµæœ
compare_models_statistically <- function(results, 
                                        metric = "c_index",
                                        dataset = "test") {
  
  message("\nğŸ“Š Statistical Model Comparison")
  message(sprintf("  Metric: %s, Dataset: %s", metric, dataset))
  
  # æ¯”è¼ƒç”¨ã®ãƒ‡ãƒ¼ã‚¿æŠ½å‡º
  comparison_data <- data.frame()
  
  for (model_name in names(results$results)) {
    model_result <- results$results[[model_name]]
    
    if (!is.null(model_result) && !is.null(model_result[[dataset]])) {
      
      if (metric == "c_index") {
        value <- model_result[[dataset]]$c_index$c_index
        se <- model_result[[dataset]]$c_index$se
        
      } else if (metric == "brier") {
        value <- model_result[[dataset]]$brier$brier_score
        se <- NA  # Brier scoreã®æ¨™æº–èª¤å·®ã¯é€šå¸¸è¨ˆç®—ã—ãªã„
        
      } else {
        value <- NA
        se <- NA
      }
      
      comparison_data <- rbind(comparison_data, data.frame(
        model = model_name,
        value = value,
        se = se
      ))
    }
  }
  
  # ãƒ©ãƒ³ã‚­ãƒ³ã‚°
  comparison_data <- comparison_data[order(comparison_data$value, 
                                         decreasing = (metric == "c_index")), ]
  comparison_data$rank <- 1:nrow(comparison_data)
  
  # æœ€è‰¯ãƒ¢ãƒ‡ãƒ«
  best_model <- comparison_data$model[1]
  best_value <- comparison_data$value[1]
  
  message(sprintf("\n  Best model: %s (%s = %.3f)", 
                 best_model, metric, best_value))
  
  # ä¸Šä½5ãƒ¢ãƒ‡ãƒ«
  message("\n  Top 5 models:")
  for (i in 1:min(5, nrow(comparison_data))) {
    message(sprintf("    %d. %s: %.3f", 
                   i, 
                   comparison_data$model[i],
                   comparison_data$value[i]))
  }
  
  return(comparison_data)
}
```

