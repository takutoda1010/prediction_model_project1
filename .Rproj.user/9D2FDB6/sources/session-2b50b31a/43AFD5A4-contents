---
title: "04_data_splitter"
author: "Takuto Yoshida"
date: "2025-11-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
################################################################################
# 04_data_splitter.R - ãƒ‡ãƒ¼ã‚¿åˆ†å‰²å‡¦ç†
# 
# Description: 
#   è¨“ç·´ãƒ»æ¤œè¨¼ãƒ»ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®åˆ†å‰²
#   æ™‚é–“çš„åˆ†å‰²ï¼ˆäºˆæ¸¬æœŸé–“ã‚’è€ƒæ…®ï¼‰ã€ãƒ©ãƒ³ãƒ€ãƒ åˆ†å‰²ã€å±¤åˆ¥åŒ–åˆ†å‰²
#   ã‚¯ãƒ­ã‚¹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨åˆ†å‰²
#
# Author: Takuto Yoshida
# Date: 2024-11-07
# Revised: 2024-11-07 - äºˆæ¸¬æœŸé–“ã‚’è€ƒæ…®ã—ãŸæ™‚é–“çš„åˆ†å‰²ã‚’è¿½åŠ 
################################################################################

# ========================================================================
# 1. æ™‚é–“çš„åˆ†å‰²ï¼ˆäºˆæ¸¬æœŸé–“ã‚’è€ƒæ…®ï¼‰
# ========================================================================

#' äºˆæ¸¬æœŸé–“ã‚’è€ƒæ…®ã—ãŸæ™‚é–“çš„ãƒ‡ãƒ¼ã‚¿åˆ†å‰²
#' @param df ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ 
#' @param date_col åˆ†å‰²åŸºæº–ã¨ãªã‚‹æ—¥ä»˜åˆ—åï¼ˆæ‰‹è¡“æ—¥ãªã©ï¼‰
#' @param prediction_months äºˆæ¸¬æœŸé–“ï¼ˆæœˆæ•°ï¼‰
#' @param reference_date åŸºæº–æ—¥ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šä»Šæ—¥ï¼‰
#' @param train_ratio è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã®å‰²åˆ
#' @param val_ratio æ¤œè¨¼ãƒ‡ãƒ¼ã‚¿ã®å‰²åˆ
#' @param test_ratio ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®å‰²åˆ
#' @return åˆ†å‰²ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚¹ãƒˆ
temporal_split <- function(df, 
                          date_col = "op_date",
                          prediction_months = 24,
                          reference_date = Sys.Date(),
                          train_ratio = 0.60,
                          val_ratio = 0.20,
                          test_ratio = 0.20) {
  
  message("\nğŸ“… Performing temporal split with prediction window...")
  
  # æ¯”ç‡ã®æ¤œè¨¼
  if (abs(train_ratio + val_ratio + test_ratio - 1.0) > 0.001) {
    stop("Split ratios must sum to 1.0")
  }
  
  # æ—¥ä»˜åˆ—ã®ç¢ºèª
  if (!date_col %in% names(df)) {
    stop(sprintf("Date column '%s' not found in data", date_col))
  }
  
  # ã‚«ãƒƒãƒˆã‚ªãƒ•æ—¥ã®è¨ˆç®—ï¼ˆäºˆæ¸¬æœŸé–“åˆ†é¡ã‚‹ï¼‰
  cutoff_date <- reference_date - (prediction_months * 30.44)  # æœˆã‚’æ—¥ã«å¤‰æ›
  
  message(sprintf("  Reference date: %s", reference_date))
  message(sprintf("  Prediction window: %d months", prediction_months))
  message(sprintf("  Cutoff date: %s", cutoff_date))
  
  # é©æ ¼ç—‡ä¾‹ã®é¸æŠï¼ˆæ‰‹è¡“æ—¥ãŒã‚«ãƒƒãƒˆã‚ªãƒ•ä»¥å‰ï¼‰
  df_eligible <- df[df[[date_col]] <= cutoff_date & !is.na(df[[date_col]]), ]
  
  # é™¤å¤–ç—‡ä¾‹ã®æƒ…å ±
  n_excluded <- nrow(df) - nrow(df_eligible)
  if (n_excluded > 0) {
    excluded_dates <- df[[date_col]][df[[date_col]] > cutoff_date & !is.na(df[[date_col]])]
    message(sprintf("  âš  Excluded %d cases with %s after cutoff", 
                   length(excluded_dates), date_col))
    
    if (length(excluded_dates) <= 5) {
      message(sprintf("    Excluded dates: %s", 
                     paste(excluded_dates, collapse = ", ")))
    } else {
      message(sprintf("    Date range of excluded: %s to %s",
                     min(excluded_dates), max(excluded_dates)))
    }
  }
  
  # NAã®å‡¦ç†
  n_na <- sum(is.na(df[[date_col]]))
  if (n_na > 0) {
    message(sprintf("  âš  %d rows with missing %s were excluded", n_na, date_col))
  }
  
  # æ—¥ä»˜ã§ã‚½ãƒ¼ãƒˆ
  df_sorted <- df_eligible[order(df_eligible[[date_col]]), ]
  
  n_total <- nrow(df_sorted)
  
  if (n_total == 0) {
    stop("No eligible cases after applying cutoff date")
  }
  
  # åˆ†å‰²æ•°ã®è¨ˆç®—
  n_train <- floor(n_total * train_ratio)
  n_val <- floor(n_total * val_ratio)
  n_test <- n_total - n_train - n_val
  
  # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ä½œæˆ
  train_idx <- 1:n_train
  val_idx <- (n_train + 1):(n_train + n_val)
  test_idx <- (n_train + n_val + 1):n_total
  
  # ãƒ‡ãƒ¼ã‚¿ã®åˆ†å‰²
  result <- list(
    train = df_sorted[train_idx, ],
    val = df_sorted[val_idx, ],
    test = df_sorted[test_idx, ],
    
    # é™¤å¤–ãƒ‡ãƒ¼ã‚¿ã‚‚ä¿å­˜ï¼ˆå‚è€ƒç”¨ï¼‰
    excluded = df[df[[date_col]] > cutoff_date | is.na(df[[date_col]]), ],
    
    # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚‚ä¿å­˜
    indices = list(
      train = train_idx,
      val = val_idx,
      test = test_idx
    ),
    
    # ãƒ¡ã‚¿æƒ…å ±
    meta = list(
      method = "temporal",
      date_col = date_col,
      prediction_months = prediction_months,
      reference_date = reference_date,
      cutoff_date = cutoff_date,
      train_ratio = train_ratio,
      val_ratio = val_ratio,
      test_ratio = test_ratio,
      n_total = n_total,
      n_train = n_train,
      n_val = n_val,
      n_test = n_test,
      n_excluded = n_excluded
    )
  )
  
  # æ—¥ä»˜ç¯„å›²ã®è¡¨ç¤º
  train_range <- range(result$train[[date_col]], na.rm = TRUE)
  val_range <- range(result$val[[date_col]], na.rm = TRUE)
  test_range <- range(result$test[[date_col]], na.rm = TRUE)
  
  message(sprintf("\n  âœ“ Eligible cases: %d (before %s)", n_total, cutoff_date))
  message(sprintf("  âœ“ Train: n=%d (%s to %s)", 
                 n_train, train_range[1], train_range[2]))
  message(sprintf("  âœ“ Val:   n=%d (%s to %s)", 
                 n_val, val_range[1], val_range[2]))
  message(sprintf("  âœ“ Test:  n=%d (%s to %s)", 
                 n_test, test_range[1], test_range[2]))
  
  # å„ã‚»ãƒƒãƒˆãŒäºˆæ¸¬æœŸé–“ã®è¦ä»¶ã‚’æº€ãŸã™ã‹ç¢ºèª
  verify_prediction_window(result, date_col, reference_date, prediction_months)
  
  class(result) <- c("data_split", "list")
  return(result)
}

#' äºˆæ¸¬æœŸé–“ã®è¦ä»¶ã‚’ç¢ºèª
#' @param split_result åˆ†å‰²çµæœ
#' @param date_col æ—¥ä»˜åˆ—å
#' @param reference_date åŸºæº–æ—¥
#' @param prediction_months äºˆæ¸¬æœŸé–“
verify_prediction_window <- function(split_result, date_col, reference_date, prediction_months) {
  
  message("\n  Verifying prediction window coverage:")
  
  for (set_name in c("train", "val", "test")) {
    set_data <- split_result[[set_name]]
    
    # æœ€æ–°ã®æ‰‹è¡“æ—¥ã‹ã‚‰ã®çµŒéæœŸé–“
    # set_dataã®ä¸­ã‹ã‚‰æœ€ã‚‚æ–°ã—ã„æ—¥ä»˜ã‚’å–å¾—
    latest_date <- max(set_data[[date_col]], na.rm = TRUE)
    # reference_dateã‹ã‚‰ãã®ã‚»ãƒƒãƒˆã®æœ€ã‚‚æ–°ã—ã„æ—¥ä»˜ã‚’å¼•ãç®—ã—çµŒéæœŸé–“ã‚’è¨ˆç®—
    months_elapsed <- as.numeric(reference_date - latest_date) / 30.44
    
    if (months_elapsed >= prediction_months) {
      message(sprintf("    %s: âœ“ Latest case has %.1f months follow-up (>= %d months)",
                     stringr::str_to_title(set_name), 
                     months_elapsed, 
                     prediction_months))
    } else {
      warning(sprintf("    %s: âš  Latest case has only %.1f months follow-up (< %d months)",
                     stringr::str_to_title(set_name), 
                     months_elapsed, 
                     prediction_months))
    }
  }
}

# ========================================================================
# 2. ãƒ©ãƒ³ãƒ€ãƒ åˆ†å‰²
# ========================================================================

#' ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‡ãƒ¼ã‚¿åˆ†å‰²ï¼ˆäºˆæ¸¬æœŸé–“ãƒ•ã‚£ãƒ«ã‚¿ä»˜ãï¼‰
#' @param df ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ 
#' @param date_col ãƒ•ã‚£ãƒ«ã‚¿ç”¨ã®æ—¥ä»˜åˆ—ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
#' @param prediction_months äºˆæ¸¬æœŸé–“ï¼ˆæœˆæ•°ï¼‰
#' @param reference_date åŸºæº–æ—¥
#' @param train_ratio è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã®å‰²åˆ
#' @param val_ratio æ¤œè¨¼ãƒ‡ãƒ¼ã‚¿ã®å‰²åˆ
#' @param test_ratio ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®å‰²åˆ
#' @param seed ä¹±æ•°ã‚·ãƒ¼ãƒ‰
#' @return åˆ†å‰²ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚¹ãƒˆ
random_split <- function(df,
                        date_col = NULL,
                        prediction_months = NULL,
                        reference_date = Sys.Date(),
                        train_ratio = 0.60,
                        val_ratio = 0.20,
                        test_ratio = 0.20,
                        seed = NULL) {
  
  message("\nğŸ² Performing random split...")
  
  # æ¯”ç‡ã®æ¤œè¨¼
  if (abs(train_ratio + val_ratio + test_ratio - 1.0) > 0.001) {
    stop("Split ratios must sum to 1.0")
  }
  
  # äºˆæ¸¬æœŸé–“ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
  df_to_split <- df
  n_excluded <- 0
  cutoff_date <- NULL
  
  if (!is.null(date_col) && !is.null(prediction_months)) {
    cutoff_date <- reference_date - (prediction_months * 30.44)
    df_to_split <- df[df[[date_col]] <= cutoff_date & !is.na(df[[date_col]]), ]
    n_excluded <- nrow(df) - nrow(df_to_split)
    
    message(sprintf("  Applied prediction window filter:"))
    message(sprintf("    Cutoff date: %s", cutoff_date))
    message(sprintf("    Excluded: %d cases", n_excluded))
  }
  
  # ä¹±æ•°ã‚·ãƒ¼ãƒ‰ã®è¨­å®š
  if (!is.null(seed)) {
    set.seed(seed)
    message(sprintf("  Random seed: %d", seed))
  }
  
  n_total <- nrow(df_to_split)
  
  if (n_total == 0) {
    stop("No cases available for splitting")
  }
  
  n_train <- floor(n_total * train_ratio)
  n_val <- floor(n_total * val_ratio)
  n_test <- n_total - n_train - n_val
  
  # ãƒ©ãƒ³ãƒ€ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  shuffled_idx <- sample(n_total)
  
  train_idx <- shuffled_idx[1:n_train]
  val_idx <- shuffled_idx[(n_train + 1):(n_train + n_val)]
  test_idx <- shuffled_idx[(n_train + n_val + 1):n_total]
  
  # ãƒ‡ãƒ¼ã‚¿ã®åˆ†å‰²
  result <- list(
    train = df_to_split[train_idx, ],
    val = df_to_split[val_idx, ],
    test = df_to_split[test_idx, ],
    
    # é™¤å¤–ãƒ‡ãƒ¼ã‚¿ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
    excluded = if(n_excluded > 0) df[df[[date_col]] > cutoff_date | is.na(df[[date_col]]), ] else NULL,
    
    indices = list(
      train = train_idx,
      val = val_idx,
      test = test_idx
    ),
    
    meta = list(
      method = "random",
      date_col = date_col,
      prediction_months = prediction_months,
      reference_date = reference_date,
      cutoff_date = cutoff_date,
      seed = seed,
      train_ratio = train_ratio,
      val_ratio = val_ratio,
      test_ratio = test_ratio,
      n_total = n_total,
      n_train = n_train,
      n_val = n_val,
      n_test = n_test,
      n_excluded = n_excluded
    )
  )
  
  message(sprintf("  âœ“ Train: n=%d (%.1f%%)", n_train, 100 * train_ratio))
  message(sprintf("  âœ“ Val:   n=%d (%.1f%%)", n_val, 100 * val_ratio))
  message(sprintf("  âœ“ Test:  n=%d (%.1f%%)", n_test, 100 * test_ratio))
  
  class(result) <- c("data_split", "list")
  return(result)
}

# ========================================================================
# 3. å±¤åˆ¥åŒ–åˆ†å‰²ï¼ˆäºˆæ¸¬æœŸé–“ãƒ•ã‚£ãƒ«ã‚¿ä»˜ãï¼‰
# ========================================================================

#' ã‚¢ã‚¦ãƒˆã‚«ãƒ ã§å±¤åˆ¥åŒ–ã—ãŸãƒ‡ãƒ¼ã‚¿åˆ†å‰²
#' @param df ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ 
#' @param outcome_col ã‚¢ã‚¦ãƒˆã‚«ãƒ åˆ—å
#' @param date_col ãƒ•ã‚£ãƒ«ã‚¿ç”¨ã®æ—¥ä»˜åˆ—ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
#' @param prediction_months äºˆæ¸¬æœŸé–“ï¼ˆæœˆæ•°ï¼‰
#' @param reference_date åŸºæº–æ—¥
#' @param train_ratio è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã®å‰²åˆ
#' @param val_ratio æ¤œè¨¼ãƒ‡ãƒ¼ã‚¿ã®å‰²åˆ
#' @param test_ratio ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®å‰²åˆ
#' @param seed ä¹±æ•°ã‚·ãƒ¼ãƒ‰
#' @return åˆ†å‰²ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚¹ãƒˆ
stratified_split <- function(df,
                            outcome_col = "recur_2y",
                            date_col = NULL,
                            prediction_months = NULL,
                            reference_date = Sys.Date(),
                            train_ratio = 0.60,
                            val_ratio = 0.20,
                            test_ratio = 0.20,
                            seed = NULL) {
  
  message("\nâš–ï¸ Performing stratified split...")
  
  # æ¯”ç‡ã®æ¤œè¨¼
  if (abs(train_ratio + val_ratio + test_ratio - 1.0) > 0.001) {
    stop("Split ratios must sum to 1.0")
  }
  
  # ã‚¢ã‚¦ãƒˆã‚«ãƒ åˆ—ã®ç¢ºèª
  if (!outcome_col %in% names(df)) {
    stop(sprintf("Outcome column '%s' not found", outcome_col))
  }
  
  # äºˆæ¸¬æœŸé–“ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
  df_to_split <- df
  n_excluded <- 0
  cutoff_date <- NULL
  
  if (!is.null(date_col) && !is.null(prediction_months)) {
    cutoff_date <- reference_date - (prediction_months * 30.44)
    df_to_split <- df[df[[date_col]] <= cutoff_date & !is.na(df[[date_col]]), ]
    n_excluded <- nrow(df) - nrow(df_to_split)
    
    message(sprintf("  Applied prediction window filter:"))
    message(sprintf("    Cutoff date: %s", cutoff_date))
    message(sprintf("    Excluded: %d cases", n_excluded))
  }
  
  # ä¹±æ•°ã‚·ãƒ¼ãƒ‰è¨­å®š
  if (!is.null(seed)) {
    set.seed(seed)
    message(sprintf("  Random seed: %d", seed))
  }
  
  # ã‚¢ã‚¦ãƒˆã‚«ãƒ ã®ãƒ¬ãƒ™ãƒ«åˆ¥ã«åˆ†å‰²
  outcome <- df_to_split[[outcome_col]]
  
  # NAå‡¦ç†
  if (any(is.na(outcome))) {
    message(sprintf("  âš  %d rows with missing outcome will be handled separately",
                   sum(is.na(outcome))))
  }
  
  # å„å±¤ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  levels_outcome <- unique(outcome[!is.na(outcome)])
  train_idx <- c()
  val_idx <- c()
  test_idx <- c()
  
  for (level in levels_outcome) {
    level_idx <- which(outcome == level)
    n_level <- length(level_idx)
    
    # å„å±¤å†…ã§ã®åˆ†å‰²æ•°
    n_train_level <- floor(n_level * train_ratio)
    n_val_level <- floor(n_level * val_ratio)
    n_test_level <- n_level - n_train_level - n_val_level
    
    # ã‚·ãƒ£ãƒƒãƒ•ãƒ«
    shuffled <- sample(level_idx)
    
    # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å‰²ã‚Šå½“ã¦
    train_idx <- c(train_idx, shuffled[1:n_train_level])
    val_idx <- c(val_idx, shuffled[(n_train_level + 1):(n_train_level + n_val_level)])
    test_idx <- c(test_idx, shuffled[(n_train_level + n_val_level + 1):n_level])
  }
  
  # NAè¡Œã®å‡¦ç†ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ã«å‰²ã‚Šå½“ã¦ï¼‰
  na_idx <- which(is.na(outcome))
  if (length(na_idx) > 0) {
    n_na <- length(na_idx)
    n_train_na <- floor(n_na * train_ratio)
    n_val_na <- floor(n_na * val_ratio)
    
    shuffled_na <- sample(na_idx)
    train_idx <- c(train_idx, shuffled_na[1:n_train_na])
    val_idx <- c(val_idx, shuffled_na[(n_train_na + 1):(n_train_na + n_val_na)])
    test_idx <- c(test_idx, shuffled_na[(n_train_na + n_val_na + 1):n_na])
  }
  
  # ãƒ‡ãƒ¼ã‚¿ã®åˆ†å‰²
  result <- list(
    train = df_to_split[train_idx, ],
    val = df_to_split[val_idx, ],
    test = df_to_split[test_idx, ],
    
    # é™¤å¤–ãƒ‡ãƒ¼ã‚¿ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
    excluded = if(n_excluded > 0) df[df[[date_col]] > cutoff_date | is.na(df[[date_col]]), ] else NULL,
    
    indices = list(
      train = train_idx,
      val = val_idx,
      test = test_idx
    ),
    
    meta = list(
      method = "stratified",
      outcome_col = outcome_col,
      date_col = date_col,
      prediction_months = prediction_months,
      reference_date = reference_date,
      cutoff_date = cutoff_date,
      seed = seed,
      train_ratio = train_ratio,
      val_ratio = val_ratio,
      test_ratio = test_ratio,
      n_total = nrow(df_to_split),
      n_train = length(train_idx),
      n_val = length(val_idx),
      n_test = length(test_idx),
      n_excluded = n_excluded
    )
  )
  
  # å±¤åˆ¥åŒ–ã®ç¢ºèª
  check_stratification(result, outcome_col)
  
  class(result) <- c("data_split", "list")
  return(result)
}

# ========================================================================
# 4. ã‚¯ãƒ­ã‚¹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨åˆ†å‰²
# ========================================================================

#' k-fold ã‚¯ãƒ­ã‚¹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åˆ†å‰²
#' @param df ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆæ—¢ã«ãƒ•ã‚£ãƒ«ã‚¿æ¸ˆã¿ã‚’æƒ³å®šï¼‰
#' @param k ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰æ•°
#' @param stratified å±¤åˆ¥åŒ–ã™ã‚‹ã‹
#' @param outcome_col å±¤åˆ¥åŒ–ç”¨ã®ã‚¢ã‚¦ãƒˆã‚«ãƒ åˆ—
#' @param seed ä¹±æ•°ã‚·ãƒ¼ãƒ‰
#' @return CVåˆ†å‰²ã®ãƒªã‚¹ãƒˆ
create_cv_folds <- function(df,
                           k = 5,
                           stratified = TRUE,
                           outcome_col = "recur_2y",
                           seed = NULL) {
  
  message(sprintf("\nğŸ”„ Creating %d-fold cross-validation splits...", k))
  
  # ä¹±æ•°ã‚·ãƒ¼ãƒ‰è¨­å®š
  if (!is.null(seed)) {
    set.seed(seed)
    message(sprintf("  Random seed: %d", seed))
  }
  
  n_total <- nrow(df)
  
  if (stratified && outcome_col %in% names(df)) {
    # å±¤åˆ¥åŒ–CV
    message("  Using stratified CV")
    
    outcome <- df[[outcome_col]]
    folds <- vector("list", k)
    
    # å„ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’åˆæœŸåŒ–
    for (i in 1:k) {
      folds[[i]] <- integer()
    }
    
    # å„å±¤ã”ã¨ã«åˆ†å‰²
    for (level in unique(outcome[!is.na(outcome)])) {
      level_idx <- which(outcome == level)
      level_idx <- sample(level_idx)  # ã‚·ãƒ£ãƒƒãƒ•ãƒ«
      
      # å„ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã«å‡ç­‰ã«å‰²ã‚Šå½“ã¦
      fold_assignments <- rep(1:k, length.out = length(level_idx))
      
      for (i in 1:k) {
        folds[[i]] <- c(folds[[i]], level_idx[fold_assignments == i])
      }
    }
    
    # NAè¡Œã®å‡¦ç†
    na_idx <- which(is.na(outcome))
    if (length(na_idx) > 0) {
      na_idx <- sample(na_idx)
      fold_assignments <- rep(1:k, length.out = length(na_idx))
      for (i in 1:k) {
        folds[[i]] <- c(folds[[i]], na_idx[fold_assignments == i])
      }
    }
    
  } else {
    # é€šå¸¸ã®CV
    message("  Using standard CV")
    
    # ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«
    shuffled_idx <- sample(n_total)
    
    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã«åˆ†å‰²
    folds <- split(shuffled_idx, cut(seq_along(shuffled_idx), k, labels = FALSE))
  }
  
  # CVåˆ†å‰²ã®ä½œæˆ
  cv_splits <- vector("list", k)
  
  for (i in 1:k) {
    test_idx <- folds[[i]]
    train_idx <- unlist(folds[-i])
    
    cv_splits[[i]] <- list(
      train = df[train_idx, ],
      test = df[test_idx, ],
      fold = i,
      train_idx = train_idx,
      test_idx = test_idx
    )
  }
  
  # çµæœã®æ§‹é€ åŒ–
  result <- list(
    splits = cv_splits,
    k = k,
    n_total = n_total,
    stratified = stratified,
    outcome_col = outcome_col,
    seed = seed,
    
    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã‚µã‚¤ã‚ºã®æƒ…å ±
    fold_sizes = sapply(cv_splits, function(x) length(x$test_idx))
  )
  
  # ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã‚µã‚¤ã‚ºã®è¡¨ç¤º
  message(sprintf("  âœ“ Created %d folds", k))
  message(sprintf("  âœ“ Fold sizes: min=%d, max=%d, mean=%.1f",
                 min(result$fold_sizes),
                 max(result$fold_sizes),
                 mean(result$fold_sizes)))
  
  if (stratified && outcome_col %in% names(df)) {
    # å„ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã®ã‚¢ã‚¦ãƒˆã‚«ãƒ åˆ†å¸ƒã‚’ç¢ºèª
    check_cv_stratification(cv_splits, outcome_col)
  }
  
  class(result) <- c("cv_folds", "list")
  return(result)
}

# ========================================================================
# 5. åˆ†å‰²ã®æ¤œè¨¼ãƒ»è©•ä¾¡é–¢æ•°
# ========================================================================

#' å±¤åˆ¥åŒ–ã®ç¢ºèª
#' @param split_result åˆ†å‰²çµæœ
#' @param outcome_col ã‚¢ã‚¦ãƒˆã‚«ãƒ åˆ—å
check_stratification <- function(split_result, outcome_col) {
  
  message("\n  Checking stratification balance:")
  
  # å„ã‚»ãƒƒãƒˆã®ã‚¢ã‚¦ãƒˆã‚«ãƒ åˆ†å¸ƒ
  train_dist <- table(split_result$train[[outcome_col]], useNA = "ifany")
  val_dist <- table(split_result$val[[outcome_col]], useNA = "ifany")
  test_dist <- table(split_result$test[[outcome_col]], useNA = "ifany")
  
  # æ¯”ç‡ã®è¨ˆç®—
  train_prop <- prop.table(train_dist)
  val_prop <- prop.table(val_dist)
  test_prop <- prop.table(test_dist)
  
  # è¡¨ç¤ºç”¨ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ
  levels_all <- unique(c(names(train_prop), names(val_prop), names(test_prop)))
  
  for (level in levels_all) {
    train_p <- ifelse(level %in% names(train_prop), 
                      sprintf("%.1f%%", 100 * train_prop[level]), "0.0%")
    val_p <- ifelse(level %in% names(val_prop), 
                    sprintf("%.1f%%", 100 * val_prop[level]), "0.0%")
    test_p <- ifelse(level %in% names(test_prop), 
                     sprintf("%.1f%%", 100 * test_prop[level]), "0.0%")
    
    message(sprintf("    %s: Train=%s, Val=%s, Test=%s",
                   ifelse(is.na(level), "NA", level),
                   train_p, val_p, test_p))
  }
}

#' CVå±¤åˆ¥åŒ–ã®ç¢ºèª
#' @param cv_splits CVåˆ†å‰²ãƒªã‚¹ãƒˆ
#' @param outcome_col ã‚¢ã‚¦ãƒˆã‚«ãƒ åˆ—å
check_cv_stratification <- function(cv_splits, outcome_col) {
  
  message("  CV stratification check:")
  
  # å„ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã®ã‚¤ãƒ™ãƒ³ãƒˆç‡
  event_rates <- sapply(cv_splits, function(fold) {
    outcome <- fold$test[[outcome_col]]
    if (is.logical(outcome) || is.numeric(outcome)) {
      mean(outcome == TRUE | outcome == 1, na.rm = TRUE)
    } else {
      NA
    }
  })
  
  if (any(!is.na(event_rates))) {
    message(sprintf("    Event rates: mean=%.1f%%, sd=%.1f%%",
                   100 * mean(event_rates, na.rm = TRUE),
                   100 * sd(event_rates, na.rm = TRUE)))
  }
}

# ========================================================================
# 6. åˆ†å‰²çµæœã®ä¿å­˜ã¨èª­ã¿è¾¼ã¿
# ========================================================================

#' åˆ†å‰²çµæœã‚’ä¿å­˜
#' @param split_result åˆ†å‰²çµæœ
#' @param file_path ä¿å­˜å…ˆãƒ‘ã‚¹
save_split <- function(split_result, file_path) {
  
  # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
  dir_path <- dirname(file_path)
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE, showWarnings = FALSE)
  }
  
  # RDSå½¢å¼ã§ä¿å­˜
  saveRDS(split_result, file = file_path)
  message(sprintf("  âœ“ Split saved to: %s", file_path))
}

#' åˆ†å‰²çµæœã‚’èª­ã¿è¾¼ã¿
#' @param file_path ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
#' @return åˆ†å‰²çµæœ
load_split <- function(file_path) {
  
  if (!file.exists(file_path)) {
    stop(sprintf("Split file not found: %s", file_path))
  }
  
  split_result <- readRDS(file_path)
  message(sprintf("  âœ“ Split loaded from: %s", file_path))
  
  return(split_result)
}

# ========================================================================
# 7. çµ±åˆåˆ†å‰²é–¢æ•°
# ========================================================================

#' ãƒ‡ãƒ¼ã‚¿åˆ†å‰²ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
#' @param df ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ 
#' @param config è¨­å®šãƒªã‚¹ãƒˆ
#' @param method åˆ†å‰²æ–¹æ³•ï¼ˆ"temporal", "random", "stratified"ï¼‰
#' @param prediction_months äºˆæ¸¬æœŸé–“ï¼ˆæœˆæ•°ï¼‰
#' @param reference_date åŸºæº–æ—¥
#' @param create_cv CVãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã‚‚ä½œæˆã™ã‚‹ã‹
#' @return åˆ†å‰²çµæœ
split_data_pipeline <- function(df,
                               config = NULL,
                               method = "temporal",
                               prediction_months = 24,
                               reference_date = "auto",
                               create_cv = TRUE) {
  
  message("\n========================================")
  message("Starting Data Splitting Pipeline")
  message("========================================")
    # reference_dateã®è‡ªå‹•è¨ˆç®—
  if (reference_date == "auto" && "op_date" %in% names(df)) {
    latest_date <- max(df$op_date, na.rm = TRUE)
    optimal_date <- latest_date + (prediction_months * 30.44)
    
    if (optimal_date > Sys.Date()) {
      reference_date <- Sys.Date()
      message("âš  Latest data too recent, using today as reference")
    } else {
      reference_date <- optimal_date
      message(sprintf("âœ“ Auto-calculated optimal reference date: %s", reference_date))
    }
  } else if (reference_date == "auto") {
    reference_date <- Sys.Date()
    message("âš  No op_date column, using today as reference")
  }

  # è¨­å®šã®å–å¾—
  if (!is.null(config)) {
    train_ratio <- config$model$train_ratio
    val_ratio <- config$model$val_ratio
    test_ratio <- config$model$test_ratio
    seed <- config$model$seed
    cv_folds <- config$model$cv_folds
    
    # äºˆæ¸¬æ™‚é–“ã®å–å¾—ï¼ˆè¨­å®šã«ã‚ã‚Œã°ï¼‰
    if (!is.null(config$model$prediction_time)) {
      prediction_months <- config$model$prediction_time
    }
  } else {
    train_ratio <- 0.60
    val_ratio <- 0.20
    test_ratio <- 0.20
    seed <- 20251102
    cv_folds <- 5
  }
  
  # ãƒ¡ã‚¤ãƒ³åˆ†å‰²
  if (method == "temporal") {
    split_result <- temporal_split(
      df,
      date_col = "op_date",
      prediction_months = prediction_months,
      reference_date = reference_date,
      train_ratio = train_ratio,
      val_ratio = val_ratio,
      test_ratio = test_ratio
    )
    
  } else if (method == "random") {
    split_result <- random_split(
      df,
      date_col = "op_date",  # ãƒ•ã‚£ãƒ«ã‚¿ç”¨
      prediction_months = prediction_months,
      reference_date = reference_date,
      train_ratio = train_ratio,
      val_ratio = val_ratio,
      test_ratio = test_ratio,
      seed = seed
    )
    
  } else if (method == "stratified") {
    split_result <- stratified_split(
      df,
      outcome_col = "recur_2y",
      date_col = "op_date",  # ãƒ•ã‚£ãƒ«ã‚¿ç”¨
      prediction_months = prediction_months,
      reference_date = reference_date,
      train_ratio = train_ratio,
      val_ratio = val_ratio,
      test_ratio = test_ratio,
      seed = seed
    )
    
  } else {
    stop(sprintf("Unknown split method: %s", method))
  }
  
  # CVåˆ†å‰²ï¼ˆè¨“ç·´ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ï¼‰
  if (create_cv && nrow(split_result$train) > 0) {
    message("\nğŸ“Š Creating CV folds for training data...")
    
    cv_result <- create_cv_folds(
      split_result$train,
      k = cv_folds,
      stratified = TRUE,
      outcome_col = "recur_2y",
      seed = seed
    )
    
    split_result$cv <- cv_result
  }
  
  # ã‚µãƒãƒªãƒ¼è¡¨ç¤º
  message("\nğŸ“ˆ Split Summary:")
  message(sprintf("  Method: %s", method))
  message(sprintf("  Prediction window: %d months", prediction_months))
  message(sprintf("  Reference date: %s", reference_date))
  message(sprintf("  Total samples: %d", nrow(df)))
  
  if (!is.null(split_result$meta$n_excluded) && split_result$meta$n_excluded > 0) {
    message(sprintf("  Excluded (too recent): %d", split_result$meta$n_excluded))
  }
  
  message(sprintf("  Training: %d (%.1f%%)", 
                 nrow(split_result$train), 
                 100 * nrow(split_result$train) / 
                   (nrow(df) - ifelse(is.null(split_result$meta$n_excluded), 0, split_result$meta$n_excluded))))
  message(sprintf("  Validation: %d (%.1f%%)", 
                 nrow(split_result$val),
                 100 * nrow(split_result$val) / 
                   (nrow(df) - ifelse(is.null(split_result$meta$n_excluded), 0, split_result$meta$n_excluded))))
  message(sprintf("  Test: %d (%.1f%%)", 
                 nrow(split_result$test),
                 100 * nrow(split_result$test) / 
                   (nrow(df) - ifelse(is.null(split_result$meta$n_excluded), 0, split_result$meta$n_excluded))))
  
  if (create_cv) {
    message(sprintf("  CV folds: %d", cv_folds))
  }
  
  message("\nâœ… Data splitting completed!")
  message("========================================\n")
  
  return(split_result)
}

# ========================================================================
# 8. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
# ========================================================================

#' åˆ†å‰²ã®ãƒãƒ©ãƒ³ã‚¹ã‚’å¯è¦–åŒ–
#' @param split_result åˆ†å‰²çµæœ
#' @param variables ç¢ºèªã™ã‚‹å¤‰æ•°åã®ãƒ™ã‚¯ãƒˆãƒ«
plot_split_balance <- function(split_result, 
                              variables = c("recur_2y", "stage_diag", "age")) {
  
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    message("ggplot2 not available for plotting")
    return(NULL)
  }
  
  # å„ã‚»ãƒƒãƒˆã«ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
  train_df <- split_result$train
  train_df$split <- "Train"
  
  val_df <- split_result$val
  val_df$split <- "Val"
  
  test_df <- split_result$test
  test_df$split <- "Test"
  
  # çµåˆ
  combined <- rbind(train_df, val_df, test_df)
  combined$split <- factor(combined$split, levels = c("Train", "Val", "Test"))
  
  # ãƒ—ãƒ­ãƒƒãƒˆä½œæˆ
  plots <- list()
  
  for (var in variables) {
    if (var %in% names(combined)) {
      if (is.numeric(combined[[var]])) {
        # æ•°å€¤å¤‰æ•°ï¼šãƒœãƒƒã‚¯ã‚¹ãƒ—ãƒ­ãƒƒãƒˆ
        p <- ggplot(combined, aes_string(x = "split", y = var, fill = "split")) +
          geom_boxplot(alpha = 0.7) +
          theme_minimal() +
          labs(title = sprintf("Distribution of %s", var)) +
          theme(legend.position = "none")
        
      } else {
        # ã‚«ãƒ†ã‚´ãƒªå¤‰æ•°ï¼šæ£’ã‚°ãƒ©ãƒ•
        p <- ggplot(combined, aes_string(x = "split", fill = var)) +
          geom_bar(position = "fill") +
          theme_minimal() +
          labs(title = sprintf("Distribution of %s", var), y = "Proportion") +
          scale_y_continuous(labels = scales::percent)
      }
      
      plots[[var]] <- p
    }
  }
  
  return(plots)
}

#' åˆ†å‰²ã‚µãƒãƒªãƒ¼ã®è©³ç´°è¡¨ç¤º
#' @param split_result åˆ†å‰²çµæœ
print_split_summary <- function(split_result) {
  
  message("\n========================================")
  message("Detailed Split Summary")
  message("========================================")
  
  # ãƒ¡ã‚¿æƒ…å ±
  meta <- split_result$meta
  message(sprintf("\nMethod: %s", meta$method))
  
  if (!is.null(meta$prediction_months)) {
    message(sprintf("Prediction window: %d months", meta$prediction_months))
  }
  
  if (!is.null(meta$cutoff_date)) {
    message(sprintf("Cutoff date: %s", meta$cutoff_date))
  }
  
  if (!is.null(meta$reference_date)) {
    message(sprintf("Reference date: %s", meta$reference_date))
  }
  
  # å„ã‚»ãƒƒãƒˆã®è©³ç´°
  sets <- c("train", "val", "test")
  
  for (set_name in sets) {
    set_data <- split_result[[set_name]]
    message(sprintf("\n%s Set:", stringr::str_to_title(set_name)))
    message(sprintf("  N = %d", nrow(set_data)))
    
    # æ—¥ä»˜ç¯„å›²ï¼ˆop_dateãŒã‚ã‚‹å ´åˆï¼‰
    if ("op_date" %in% names(set_data)) {
      date_range <- range(set_data$op_date, na.rm = TRUE)
      message(sprintf("  Date range: %s to %s", date_range[1], date_range[2]))
    }
    
    # ã‚¢ã‚¦ãƒˆã‚«ãƒ åˆ†å¸ƒï¼ˆrecur_2yãŒã‚ã‚‹å ´åˆï¼‰
    if ("recur_2y" %in% names(set_data)) {
      outcome_dist <- table(set_data$recur_2y, useNA = "ifany")
      event_rate <- mean(set_data$recur_2y == TRUE, na.rm = TRUE)
      message(sprintf("  Event rate: %.1f%%", 100 * event_rate))
    }
  }
  
  # é™¤å¤–ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚ã‚‹å ´åˆï¼‰
  if (!is.null(split_result$excluded) && nrow(split_result$excluded) > 0) {
    message(sprintf("\nExcluded Cases: %d", nrow(split_result$excluded)))
    if ("op_date" %in% names(split_result$excluded)) {
      exc_dates <- range(split_result$excluded$op_date, na.rm = TRUE)
      message(sprintf("  Date range: %s to %s", exc_dates[1], exc_dates[2]))
    }
  }
  
  message("\n========================================\n")
}
```

