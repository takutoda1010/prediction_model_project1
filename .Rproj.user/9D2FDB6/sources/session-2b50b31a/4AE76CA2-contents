---
title: "DIAG"
author: "Takuto Yoshida"
date: "2025-11-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
# ========================================
# è³ªå•1: reference_dateã®ç¢ºèª
# ========================================

message("\n" , paste(rep("=", 60), collapse = ""))
message("Q1: Reference Date Investigation")
message(paste(rep("=", 60), collapse = ""), "\n")

# split_dataã®ãƒ¡ã‚¿æƒ…å ±ã‹ã‚‰ç¢ºèª
if (exists("split_data") && !is.null(split_data$meta)) {
  message("From split_data metadata:")
  message(sprintf("  Reference date: %s", split_data$meta$reference_date))
  message(sprintf("  Cutoff date: %s", split_data$meta$cutoff_date))
  message(sprintf("  Prediction months: %d", split_data$meta$prediction_months))
  message(sprintf("  Split method: %s", split_data$meta$method))
}

# å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ã®æ—¥ä»˜ç¯„å›²ã‚’ç¢ºèª
if ("op_date" %in% names(final_data)) {
  op_date_range <- range(final_data$op_date, na.rm = TRUE)
  message("\nActual surgery date range in data:")
  message(sprintf("  Earliest: %s", op_date_range[1]))
  message(sprintf("  Latest: %s", op_date_range[2]))
  
  # æœ€æ–°æ‰‹è¡“æ—¥ã‹ã‚‰ä»Šæ—¥ã¾ã§ã®çµŒéæœˆæ•°
  months_from_latest <- as.numeric(Sys.Date() - op_date_range[2]) / 30.44
  message(sprintf("  Months from latest surgery to today: %.1f months", months_from_latest))
}

# ========================================
# è³ªå•2: DCAã®è§£é‡ˆã¨ã‚¤ãƒ™ãƒ³ãƒˆç‡
# ========================================

message("\n" , paste(rep("=", 60), collapse = ""))
message("Q2: DCA Interpretation & Event Rates")
message(paste(rep("=", 60), collapse = ""), "\n")

# å„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®ã‚¤ãƒ™ãƒ³ãƒˆç‡ã‚’è¨ˆç®—
calculate_event_rates <- function(data_list) {
  results <- data.frame()
  
  for (set_name in names(data_list)) {
    if (!is.null(data_list[[set_name]]) && "recur_2y" %in% names(data_list[[set_name]])) {
      data <- data_list[[set_name]]
      
      # 2å¹´å†ç™ºç‡
      events <- sum(data$recur_2y == TRUE | data$recur_2y == "TRUE", na.rm = TRUE)
      total <- nrow(data)
      event_rate <- events / total
      
      # å®Ÿéš›ã®2å¹´ä»¥å†…ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ™‚é–“ã‚‚è€ƒæ…®ï¼‰
      if ("time2y" %in% names(data)) {
        events_2y <- sum(data$recur_2y == TRUE & data$time2y <= 24, na.rm = TRUE)
        event_rate_2y <- events_2y / total
      } else {
        event_rate_2y <- event_rate
      }
      
      results <- rbind(results, data.frame(
        Dataset = set_name,
        N = total,
        Events = events,
        Event_Rate = sprintf("%.1f%%", event_rate * 100),
        Events_2y = events_2y,
        Event_Rate_2y = sprintf("%.1f%%", event_rate_2y * 100)
      ))
    }
  }
  
  return(results)
}

# split_data_fixedã§è¨ˆç®—
if (exists("split_data_fixed")) {
  event_rates <- calculate_event_rates(split_data_fixed)
  message("Event rates in each dataset:")
  print(event_rates)
  
  message("\nDCA Interpretation:")
  message("  - The intersection of 'Treat All' and 'Treat None' at ~0.33 threshold")
  message("    indicates the event rate in the test set is approximately 33%")
  message("  - Best Model and TNM Model show positive net benefit above this threshold")
  message("  - Models provide clinical value for threshold probabilities between ~0.15 and 0.45")
}

# ========================================
# è³ªå•3: Calibrationçµ±è¨ˆé‡ã®è©³ç´°
# ========================================

message("\n" , paste(rep("=", 60), collapse = ""))
message("Q3: Calibration Statistics")
message(paste(rep("=", 60), collapse = ""), "\n")

# best_calibrationã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰çµ±è¨ˆé‡ã‚’å–å¾—
if (exists("best_calibration") && !is.null(best_calibration)) {
  message("Calibration Statistics for Best Model:")
  message(sprintf("  Calibration-in-the-large (intercept): %.3f", best_calibration$intercept))
  message(sprintf("  Calibration slope: %.3f", best_calibration$slope))
  
  message("\nInterpretation:")
  if (best_calibration$slope < 1) {
    message("  - Slope < 1 indicates overfitting (model too extreme in predictions)")
    message("  - The model tends to overestimate high risks and underestimate low risks")
  } else if (best_calibration$slope > 1) {
    message("  - Slope > 1 indicates underfitting (predictions too moderate)")
  } else {
    message("  - Slope â‰ˆ 1 indicates good calibration")
  }
  
  if (best_calibration$intercept < 0) {
    message("  - Negative intercept: model tends to overestimate risk overall")
  } else if (best_calibration$intercept > 0) {
    message("  - Positive intercept: model tends to underestimate risk overall")
  }
  
  # Hosmer-Lemeshow test (optional)
  if (!is.null(best_calibration$groups)) {
    message("\nCalibration by risk groups:")
    print(best_calibration$groups[, c("group", "n", "expected", "observed")])
  }
}

# ========================================
# è³ªå•4: å„ãƒ¢ãƒ‡ãƒ«ã®å¤‰æ•°ã¨çµ±è¨ˆé‡
# ========================================

message("\n" , paste(rep("=", 60), collapse = ""))
message("Q4: Model Variables and Coefficients")
message(paste(rep("=", 60), collapse = ""), "\n")

# å…¨ãƒ¢ãƒ‡ãƒ«ã®ä¿‚æ•°ã‚’æŠ½å‡º
extract_all_coefficients <- function(models) {
  all_coef <- list()
  
  for (model_name in names(models)) {
    model <- models[[model_name]]
    
    if (!is.null(model)) {
      # Coxphãƒ¢ãƒ‡ãƒ«
      if (inherits(model, "coxph")) {
        model_summary <- summary(model)
        coef_df <- as.data.frame(model_summary$coefficients)
        conf_int <- as.data.frame(model_summary$conf.int)
        
        result <- data.frame(
          Model = model_name,
          Variable = rownames(coef_df),
          Beta = coef_df[, "coef"],
          SE = coef_df[, "se(coef)"],
          HR = conf_int[, "exp(coef)"],
          Lower_95CI = conf_int[, "lower .95"],
          Upper_95CI = conf_int[, "upper .95"],
          P_value = coef_df[, "Pr(>|z|)"],
          stringsAsFactors = FALSE
        )
        
        all_coef[[model_name]] <- result
        
      # ãƒªã‚¹ãƒˆå‹ãƒ¢ãƒ‡ãƒ«
      } else if (inherits(model, "list") && "model" %in% names(model) && !is.null(model$model)) {
        inner_model <- model$model
        if (inherits(inner_model, "coxph")) {
          model_summary <- summary(inner_model)
          coef_df <- as.data.frame(model_summary$coefficients)
          conf_int <- as.data.frame(model_summary$conf.int)
          
          result <- data.frame(
            Model = model_name,
            Variable = rownames(coef_df),
            Beta = coef_df[, "coef"],
            SE = coef_df[, "se(coef)"],
            HR = conf_int[, "exp(coef)"],
            Lower_95CI = conf_int[, "lower .95"],
            Upper_95CI = conf_int[, "upper .95"],
            P_value = coef_df[, "Pr(>|z|)"],
            stringsAsFactors = FALSE
          )
          
          all_coef[[model_name]] <- result
        }
      }
    }
  }
  
  # çµåˆ
  if (length(all_coef) > 0) {
    combined <- do.call(rbind, all_coef)
    rownames(combined) <- NULL
    return(combined)
  }
  
  return(NULL)
}

# å®Ÿè¡Œ
if (exists("models")) {
  model_coefficients <- extract_all_coefficients(models)
  
  if (!is.null(model_coefficients)) {
    # ãƒ™ã‚¹ãƒˆãƒ¢ãƒ‡ãƒ«ã®ã¿è¡¨ç¤ºï¼ˆå…¨ä½“ã¯å¤§ãã„ãŸã‚ï¼‰
    best_model_coef <- model_coefficients[model_coefficients$Model == best_model_name, ]
    message(sprintf("Coefficients for Best Model (%s):", best_model_name))
    print(best_model_coef, digits = 3)
    
    # CSVã¨ã—ã¦ä¿å­˜
    write.csv(model_coefficients, 
              file.path(paths$output_tables, "all_model_coefficients.csv"),
              row.names = FALSE)
    message(sprintf("\nâœ“ Full coefficient table saved to: all_model_coefficients.csv"))
    
    # å¤‰æ•°ã®ä½¿ç”¨é »åº¦
    var_frequency <- table(model_coefficients$Variable)
    var_frequency <- sort(var_frequency, decreasing = TRUE)
    message("\nTop 10 most frequently selected variables:")
    print(head(var_frequency, 10))
  }
}

# ========================================
# è³ªå•5: äºˆæ¸¬ã®æ–¹å‘æ€§ç¢ºèª
# ========================================

message("\n" , paste(rep("=", 60), collapse = ""))
message("Q5: Prediction Direction Check")
message(paste(rep("=", 60), collapse = ""), "\n")

# ãƒ™ã‚¹ãƒˆãƒ¢ãƒ‡ãƒ«ã§ç¢ºèª
if (exists("best_model") && exists("split_data_fixed")) {
  test_data <- split_data_fixed$test
  
  # ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢ã‚’å–å¾—
  if (inherits(best_model, "coxph")) {
    risk_scores <- predict(best_model, newdata = test_data, type = "risk")
    lp_scores <- predict(best_model, newdata = test_data, type = "lp")
  }
  
  # å®Ÿéš›ã®å†ç™ºã¨ã®é–¢ä¿‚
  actual_recurrence <- as.numeric(test_data$recur_2y == TRUE | test_data$recur_2y == "TRUE")
  
  # ç›¸é–¢ã‚’ç¢ºèª
  cor_risk <- cor(risk_scores, actual_recurrence, use = "complete.obs")
  cor_lp <- cor(lp_scores, actual_recurrence, use = "complete.obs")
  
  message("Prediction Direction Verification:")
  message(sprintf("  Correlation (risk score vs actual recurrence): %.3f", cor_risk))
  message(sprintf("  Correlation (linear predictor vs actual recurrence): %.3f", cor_lp))
  
  # é«˜ãƒªã‚¹ã‚¯ç¾¤ã¨ä½ãƒªã‚¹ã‚¯ç¾¤ã®å†ç™ºç‡
  risk_median <- median(risk_scores)
  high_risk <- actual_recurrence[risk_scores > risk_median]
  low_risk <- actual_recurrence[risk_scores <= risk_median]
  
  message("\nRisk Stratification Check:")
  message(sprintf("  High risk group recurrence rate: %.1f%%", mean(high_risk) * 100))
  message(sprintf("  Low risk group recurrence rate: %.1f%%", mean(low_risk) * 100))
  
  if (mean(high_risk) > mean(low_risk)) {
    message("  âœ“ Correct: Model predicts RECURRENCE (higher scores = higher risk)")
  } else {
    message("  âœ— Inverted: Model might be predicting NON-recurrence")
  }
}

# ========================================
# è³ªå•6: Test setã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ
# ========================================

message("\n" , paste(rep("=", 60), collapse = ""))
message("Q6: Test Set Performance Analysis")
message(paste(rep("=", 60), collapse = ""), "\n")

# å„ã‚»ãƒƒãƒˆã®è©³ç´°ãªç‰¹æ€§ã‚’æ¯”è¼ƒ
if (exists("split_data_fixed")) {
  
  dataset_characteristics <- data.frame()
  
  for (set_name in c("train", "val", "test")) {
    data <- split_data_fixed[[set_name]]
    
    if (!is.null(data)) {
      # åŸºæœ¬çµ±è¨ˆ
      n <- nrow(data)
      events <- sum(data$recur_2y == TRUE, na.rm = TRUE)
      event_rate <- events / n
      
      # æ™‚é–“çš„ç‰¹æ€§
      if ("op_date" %in% names(data)) {
        date_range <- range(data$op_date, na.rm = TRUE)
        date_span <- as.numeric(date_range[2] - date_range[1]) / 365.25
      } else {
        date_range <- c(NA, NA)
        date_span <- NA
      }
      
      # ãƒ•ã‚©ãƒ­ãƒ¼ã‚¢ãƒƒãƒ—æœŸé–“
      if ("time2y" %in% names(data)) {
        fu_median <- median(data$time2y, na.rm = TRUE)
        fu_mean <- mean(data$time2y, na.rm = TRUE)
      } else {
        fu_median <- NA
        fu_mean <- NA
      }
      
      dataset_characteristics <- rbind(dataset_characteristics, data.frame(
        Dataset = set_name,
        N = n,
        Events = events,
        Event_Rate = sprintf("%.1f%%", event_rate * 100),
        Start_Date = as.character(date_range[1]),
        End_Date = as.character(date_range[2]),
        Span_Years = sprintf("%.1f", date_span),
        Median_FU = sprintf("%.1f", fu_median),
        Mean_FU = sprintf("%.1f", fu_mean)
      ))
    }
  }
  
  message("Dataset Characteristics Comparison:")
  print(dataset_characteristics)
  
  message("\nPossible reasons for better test performance:")
  message("  1. Test set has more recent cases (surgical improvements)")
  message("  2. Different case mix or patient selection")
  message("  3. Temporal trends in outcomes")
  message("  4. Random variation (especially with smaller sample size)")
}

message("\n" , paste(rep("=", 60), collapse = ""))
message("END OF INVESTIGATION")
message(paste(rep("=", 60), collapse = ""))
```

```{r}
# ========================================
# Test Setæ€§èƒ½å„ªä½æ€§ã®è©³ç´°èª¿æŸ»
# ========================================

message("\n", paste(rep("=", 60), collapse = ""))
message("INVESTIGATING TEST SET PERFORMANCE ADVANTAGE")
message(paste(rep("=", 60), collapse = ""), "\n")

# 1. æ™‚ç³»åˆ—çš„ãªæ‚£è€…ç‰¹æ€§ã®å¤‰åŒ–
message("ğŸ“Š 1. Temporal Trends in Patient Characteristics")
message(paste(rep("-", 50), collapse = ""))

analyze_temporal_trends <- function(split_data) {
  results <- list()
  
  for (set_name in c("train", "val", "test")) {
    data <- split_data[[set_name]]
    
    # åŸºæœ¬çµ±è¨ˆ
    results[[set_name]] <- data.frame(
      Dataset = set_name,
      N = nrow(data),
      
      # æ—¥ä»˜ç¯„å›²
      Start_Date = min(data$op_date, na.rm = TRUE),
      End_Date = max(data$op_date, na.rm = TRUE),
      
      # æ‚£è€…èƒŒæ™¯
      Age_Mean = mean(data$age, na.rm = TRUE),
      Male_Pct = mean(data$sex == "M", na.rm = TRUE) * 100,
      
      # è‚æ©Ÿèƒ½
      ALBI_Mean = mean(data$ALBIscore, na.rm = TRUE),
      ChildA_Pct = mean(data$child_pugh == "A", na.rm = TRUE) * 100,
      
      # è…«ç˜å› å­
      Tumor_Size = mean(data$max_diam_cm, na.rm = TRUE),
      Multiple_Pct = mean(data$count > 1, na.rm = TRUE) * 100,
      
      # ã‚¹ãƒ†ãƒ¼ã‚¸åˆ†å¸ƒ
      Stage_R_Pct = mean(data$stage_diag == "R", na.rm = TRUE) * 100,
      Stage_BR1_Pct = mean(data$stage_diag == "BR1", na.rm = TRUE) * 100,
      Stage_BR2_Pct = mean(data$stage_diag == "BR2", na.rm = TRUE) * 100,
      
      # è„ˆç®¡ä¾µè¥²
      MicroVI_Pct = mean(data$microVI == TRUE, na.rm = TRUE) * 100,
      MacroVI_Pct = mean(data$macroVI == TRUE, na.rm = TRUE) * 100,
      
      # ã‚¢ã‚¦ãƒˆã‚«ãƒ 
      Recur_2y_Pct = mean(data$recur_2y == TRUE, na.rm = TRUE) * 100
    )
  }
  
  trend_table <- do.call(rbind, results)
  return(trend_table)
}

trend_analysis <- analyze_temporal_trends(split_data_fixed)
print(trend_analysis, digits = 1)

# 2. ãƒ¢ãƒ‡ãƒ«äºˆæ¸¬ã®è©³ç´°åˆ†æ
message("\nğŸ“Š 2. Model Prediction Analysis by Dataset")
message(paste(rep("-", 50), collapse = ""))

if (exists("best_model")) {
  for (set_name in c("train", "val", "test")) {
    data <- split_data_fixed[[set_name]]
    
    # ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢è¨ˆç®—
    risk_scores <- predict(best_model, newdata = data, type = "risk")
    
    # å››åˆ†ä½ã§åˆ†å‰²
    risk_quartiles <- cut(risk_scores, 
                          quantile(risk_scores, probs = c(0, 0.25, 0.5, 0.75, 1)),
                          labels = c("Q1(Low)", "Q2", "Q3", "Q4(High)"),
                          include.lowest = TRUE)
    
    # å„å››åˆ†ä½ã®å†ç™ºç‡
    message(sprintf("\n%s Set Risk Stratification:", set_name))
    for (q in levels(risk_quartiles)) {
      q_data <- data[risk_quartiles == q, ]
      recur_rate <- mean(q_data$recur_2y == TRUE, na.rm = TRUE) * 100
      n_patients <- sum(risk_quartiles == q, na.rm = TRUE)
      message(sprintf("  %s: %.1f%% (n=%d)", q, recur_rate, n_patients))
    }
  }
}

# 3. å¹´åº¦åˆ¥ã®å†ç™ºç‡ãƒˆãƒ¬ãƒ³ãƒ‰ï¼ˆä¿®æ­£ç‰ˆï¼šdplyrã‚’ä½¿ã‚ãªã„ï¼‰
message("\nğŸ“Š 3. Yearly Recurrence Rate Trends")
message(paste(rep("-", 50), collapse = ""))

# å¹´åº¦åˆ¥é›†è¨ˆ
yearly_data <- final_data
yearly_data$op_year <- as.numeric(format(yearly_data$op_date, "%Y"))
yearly_data$recur_2y_calc <- (yearly_data$recur_tf == TRUE & 
                              yearly_data$rfs_months <= 24)

# 2000-2021å¹´ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿
yearly_data <- yearly_data[yearly_data$op_year >= 2000 & 
                          yearly_data$op_year <= 2021, ]

yearly_trends <- aggregate(
  recur_2y_calc ~ op_year,
  data = yearly_data,
  FUN = function(x) c(N = length(x), Rate = mean(x, na.rm = TRUE) * 100)
)

print(yearly_trends)

# ç·šå½¢ãƒˆãƒ¬ãƒ³ãƒ‰ã®æ¤œå®š
if (nrow(yearly_trends) > 0) {
  trend_test <- cor.test(yearly_trends$op_year, 
                         yearly_trends$recur_2y_calc[, "Rate"], 
                         method = "spearman")
  message(sprintf("\nTemporal trend correlation: rho = %.3f, p = %.4f", 
                 trend_test$estimate, trend_test$p.value))
}

# 4. Train vs TestæœŸé–“ã®ãƒ¢ãƒ‡ãƒ«ä¿‚æ•°æ¯”è¼ƒ
message("\nğŸ“Š 4. Model Coefficient Stability")
message(paste(rep("-", 50), collapse = ""))

# ç°¡æ˜“æ¯”è¼ƒã®ãŸã‚ã€ä¸»è¦å¤‰æ•°ã®ã¿
if (exists("best_model")) {
  # ä¿‚æ•°ã®å–å¾—
  coef_names <- names(coef(best_model))
  message(sprintf("Model has %d coefficients", length(coef_names)))
  
  # ä¸Šä½5å¤‰æ•°ã‚’è¡¨ç¤º
  coef_vals <- abs(coef(best_model))
  top_vars <- names(sort(coef_vals, decreasing = TRUE)[1:min(5, length(coef_vals))])
  
  message("\nTop 5 predictive variables:")
  for (v in top_vars) {
    message(sprintf("  %s: Î² = %.3f", v, coef(best_model)[v]))
  }
}

# 5. ç—‡ä¾‹ã®è¤‡é›‘ã•ã®æ¯”è¼ƒ
message("\nğŸ“Š 5. Case Complexity Analysis")
message(paste(rep("-", 50), collapse = ""))

for (set_name in c("train", "val", "test")) {
  data <- split_data_fixed[[set_name]]
  
  # è¤‡é›‘ã•ã‚¹ã‚³ã‚¢ã®è¨ˆç®—
  complexity <- rep(0, nrow(data))
  
  # å„è¦å› ã‚’ãƒã‚§ãƒƒã‚¯
  if ("stage_diag" %in% names(data)) {
    complexity <- complexity + (data$stage_diag != "R")
  }
  if ("count" %in% names(data)) {
    complexity <- complexity + (data$count > 1)
  }
  if ("max_diam_cm" %in% names(data)) {
    complexity <- complexity + (data$max_diam_cm > 5)
  }
  if ("child_pugh" %in% names(data)) {
    complexity <- complexity + (data$child_pugh != "A")
  }
  if (all(c("microVI", "macroVI") %in% names(data))) {
    complexity <- complexity + (data$microVI | data$macroVI)
  }
  
  message(sprintf("\n%s Set Complexity:", set_name))
  message(sprintf("  Mean complexity score: %.2f", mean(complexity, na.rm = TRUE)))
  message(sprintf("  High complexity (â‰¥3): %.1f%%", 
                 mean(complexity >= 3, na.rm = TRUE) * 100))
}

message("\n", paste(rep("=", 60), collapse = ""))
message("INVESTIGATION COMPLETE")
message(paste(rep("=", 60), collapse = ""))
```

```{r}
# ========================================
# Calibrationã®çµ±è¨ˆçš„æ¤œå®š
# ========================================

message("\nğŸ“Š Statistical Tests for Calibration")
message(paste(rep("=", 50), collapse = ""))

# 1. Calibration Slopeã®ä¿¡é ¼åŒºé–“ã¨æ¤œå®š
test_calibration_slope <- function(model, data, B = 100) {
  
  # äºˆæ¸¬å€¤ï¼ˆç·šå½¢äºˆæ¸¬å­ï¼‰
  lp <- predict(model, newdata = data, type = "lp")
  
  # Calibration model: å®Ÿéš›ã®ã‚¢ã‚¦ãƒˆã‚«ãƒ  ~ äºˆæ¸¬å€¤
  cal_cox <- coxph(data$surv_obj ~ lp, data = data)
  
  # Slopeï¼ˆç†æƒ³ã¯1.0ï¼‰
  slope <- coef(cal_cox)
  se <- sqrt(vcov(cal_cox)[1,1])
  
  # 95%ä¿¡é ¼åŒºé–“
  ci_lower <- slope - 1.96 * se
  ci_upper <- slope + 1.96 * se
  
  # H0: slope = 1 ã®æ¤œå®š
  z_stat <- (slope - 1) / se
  p_value <- 2 * pnorm(-abs(z_stat))
  
  result <- list(
    slope = slope,
    se = se,
    ci = c(ci_lower, ci_upper),
    z_stat = z_stat,
    p_value = p_value,
    interpretation = ifelse(p_value < 0.05, 
                           "Significant miscalibration", 
                           "Adequate calibration")
  )
  
  return(result)
}

# 2. GrÃ¸nnesby-Borgan Testï¼ˆCoxå›å¸°ç”¨ã®Hosmer-Lemeshowæ¤œå®šï¼‰
gronnesby_borgan_test <- function(model, data, g = 10) {
  
  # ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢ã§ç¾¤åˆ†ã‘
  risk <- predict(model, newdata = data, type = "risk")
  
  # gç¾¤ã«åˆ†å‰²
  risk_groups <- cut(risk, 
                    breaks = quantile(risk, probs = seq(0, 1, 1/g)),
                    include.lowest = TRUE,
                    labels = FALSE)
  
  # å„ç¾¤ã®è¦³å¯Ÿãƒ»æœŸå¾…ã‚¤ãƒ™ãƒ³ãƒˆæ•°ã‚’è¨ˆç®—
  obs_events <- numeric(g)
  exp_events <- numeric(g)
  
  for(i in 1:g) {
    group_data <- data[risk_groups == i, ]
    
    # è¦³å¯Ÿã‚¤ãƒ™ãƒ³ãƒˆæ•°
    obs_events[i] <- sum(group_data$recur_2y == TRUE)
    
    # æœŸå¾…ã‚¤ãƒ™ãƒ³ãƒˆæ•°ï¼ˆNelson-Aalenæ¨å®šé‡ã‚’ä½¿ç”¨ï¼‰
    fit <- survfit(model, newdata = group_data)
    # 24ãƒ¶æœˆæ™‚ç‚¹ã§ã®æœŸå¾…ã‚¤ãƒ™ãƒ³ãƒˆç‡
    surv_24m <- summary(fit, times = 24)$surv
    exp_prob <- 1 - mean(surv_24m, na.rm = TRUE)
    exp_events[i] <- exp_prob * nrow(group_data)
  }
  
  # ã‚«ã‚¤äºŒä¹—çµ±è¨ˆé‡
  chi_sq <- sum((obs_events - exp_events)^2 / exp_events, na.rm = TRUE)
  df <- g - 1
  p_value <- pchisq(chi_sq, df, lower.tail = FALSE)
  
  result <- list(
    chi_squared = chi_sq,
    df = df,
    p_value = p_value,
    groups = g,
    observed = obs_events,
    expected = exp_events,
    interpretation = ifelse(p_value < 0.05,
                           "Poor calibration",
                           "Good calibration")
  )
  
  return(result)
}

# 3. ICI (Integrated Calibration Index)ã¨E50/E90
calculate_ici <- function(predicted, observed) {
  # äºˆæ¸¬ã¨è¦³å¯Ÿã®çµ¶å¯¾å·®ã®å¹³å‡
  ici <- mean(abs(predicted - observed))
  
  # E50: 50ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«èª¤å·®
  e50 <- quantile(abs(predicted - observed), 0.50)
  
  # E90: 90ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«èª¤å·®
  e90 <- quantile(abs(predicted - observed), 0.90)
  
  return(list(
    ICI = ici,
    E50 = e50,
    E90 = e90,
    interpretation = case_when(
      ici < 0.05 ~ "Excellent calibration",
      ici < 0.10 ~ "Good calibration",
      ici < 0.15 ~ "Moderate calibration",
      TRUE ~ "Poor calibration"
    )
  ))
}

# 4. å®Ÿè¡Œ
message("\n--- Testing Best Model Calibration ---")

# Test setã§ã®æ¤œå®š
if (exists("best_model") && exists("split_data_fixed")) {
  
  test_data <- split_data_fixed$test
  
  # Calibration slope test
  message("\n1. Calibration Slope Test:")
  slope_test <- test_calibration_slope(best_model, test_data)
  message(sprintf("  Slope: %.3f (95%% CI: %.3f-%.3f)", 
                 slope_test$slope, slope_test$ci[1], slope_test$ci[2]))
  message(sprintf("  H0: slope=1, p-value: %.4f", slope_test$p_value))
  message(sprintf("  Interpretation: %s", slope_test$interpretation))
  
  # GrÃ¸nnesby-Borgan test
  message("\n2. GrÃ¸nnesby-Borgan Test:")
  gb_test <- gronnesby_borgan_test(best_model, test_data, g = 10)
  message(sprintf("  Chi-squared: %.2f (df=%d)", gb_test$chi_squared, gb_test$df))
  message(sprintf("  p-value: %.4f", gb_test$p_value))
  message(sprintf("  Interpretation: %s", gb_test$interpretation))
  
  # ICIè¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰
  message("\n3. Calibration Metrics:")
  pred_prob <- get_predictions(best_model, test_data, time_point = 24)
  obs_prob <- as.numeric(test_data$recur_2y)
  
  ici_result <- calculate_ici(pred_prob, obs_prob)
  message(sprintf("  ICI: %.3f", ici_result$ICI))
  message(sprintf("  E50: %.3f", ici_result$E50))
  message(sprintf("  E90: %.3f", ici_result$E90))
  message(sprintf("  Interpretation: %s", ici_result$interpretation))
}

# 5. Bootstrapä¿¡é ¼åŒºé–“ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
if (FALSE) {  # æ™‚é–“ãŒã‹ã‹ã‚‹ã®ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯OFF
  message("\n4. Bootstrap Confidence Intervals:")
  
  bootstrap_calibration <- function(model, data, B = 100) {
    slopes <- numeric(B)
    
    for(i in 1:B) {
      # ãƒªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
      idx <- sample(nrow(data), replace = TRUE)
      boot_data <- data[idx, ]
      
      # Calibration slopeè¨ˆç®—
      lp <- predict(model, newdata = boot_data, type = "lp")
      cal_cox <- coxph(boot_data$surv_obj ~ lp, data = boot_data)
      slopes[i] <- coef(cal_cox)
    }
    
    return(list(
      mean_slope = mean(slopes),
      ci_95 = quantile(slopes, c(0.025, 0.975)),
      se = sd(slopes)
    ))
  }
  
  boot_result <- bootstrap_calibration(best_model, test_data, B = 100)
  message(sprintf("  Bootstrap slope: %.3f (95%% CI: %.3f-%.3f)",
                 boot_result$mean_slope, 
                 boot_result$ci_95[1], 
                 boot_result$ci_95[2]))
}
```

```{r}
# ========================================
# ãƒªã‚¹ã‚¯ç¾¤åˆ¥ã®ç”Ÿå­˜æ›²ç·šåˆ†æ
# ========================================

library(survival)
library(survminer)
library(cmprsk)  # ç«¶åˆãƒªã‚¹ã‚¯åˆ†æç”¨

message("\nğŸ“Š Risk-Stratified Survival Analysis")
message(paste(rep("=", 50), collapse = ""))

# 1. ãƒªã‚¹ã‚¯ç¾¤ã®ä½œæˆ
create_risk_groups <- function(model, data, cutoffs = c(1/3, 2/3)) {
  # ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢è¨ˆç®—
  risk_scores <- predict(model, newdata = data, type = "risk")
  
  # ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ã§ã‚«ãƒƒãƒˆ
  cuts <- quantile(risk_scores, probs = c(0, cutoffs, 1))
  
  # ãƒªã‚¹ã‚¯ç¾¤ä½œæˆ
  risk_groups <- cut(risk_scores,
                    breaks = cuts,
                    labels = c("Low", "Medium", "High"),
                    include.lowest = TRUE)
  
  return(risk_groups)
}

# 2. Test setã§ãƒªã‚¹ã‚¯ç¾¤ä½œæˆ
test_data <- split_data_fixed$test
test_data$risk_group <- create_risk_groups(best_model, test_data)

# ãƒªã‚¹ã‚¯ç¾¤åˆ¥ã®å†ç™ºç‡
message("\nRisk group distribution:")
risk_table <- table(test_data$risk_group, test_data$recur_2y)
print(prop.table(risk_table, margin = 1))

# 3. Kaplan-Meieræ›²ç·š
message("\n--- Kaplan-Meier Analysis ---")

km_fit <- survfit(Surv(time2y, recur_2y) ~ risk_group, 
                  data = test_data)

# Log-rankæ¤œå®š
survdiff_result <- survdiff(Surv(time2y, recur_2y) ~ risk_group, 
                            data = test_data)
p_value_km <- pchisq(survdiff_result$chisq, 
                     df = length(unique(test_data$risk_group)) - 1,
                     lower.tail = FALSE)

message(sprintf("Log-rank test p-value: %.4f", p_value_km))

# KMæ›²ç·šã®ä½œå›³
km_plot <- ggsurvplot(
  km_fit,
  data = test_data,
  pval = TRUE,
  pval.method = TRUE,
  risk.table = TRUE,
  risk.table.col = "strata",
  palette = c("#00BFC4", "#F8766D", "#C77CFF"),
  legend.labs = c("Low risk", "Medium risk", "High risk"),
  title = "Kaplan-Meier Curves by Risk Group",
  xlab = "Time (months)",
  ylab = "Recurrence-free probability",
  xlim = c(0, 24),
  break.time.by = 6,
  ggtheme = theme_minimal()
)

print(km_plot)

# 4. ç«¶åˆãƒªã‚¹ã‚¯åˆ†æï¼ˆä»–å› æ­»ã‚’ç«¶åˆã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦ï¼‰
message("\n--- Competing Risk Analysis ---")

# ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã®è¨­å®š
# 0: censored, 1: recurrence, 2: death without recurrence
test_data$event_type <- ifelse(
  test_data$recur_2y == TRUE, 1,
  ifelse(test_data$vital_status == "æ­»" & test_data$recur_2y == FALSE, 2, 0)
)

# Cumulative Incidence Function
cif_result <- cuminc(
  ftime = test_data$time2y,
  fstatus = test_data$event_type,
  group = test_data$risk_group,
  rho = 0,
  cencode = 0
)

# Gray's testï¼ˆç«¶åˆãƒªã‚¹ã‚¯ç‰ˆã®log-rank testï¼‰
gray_test_p <- cif_result$Tests[1, 2]
message(sprintf("Gray's test p-value: %.4f", gray_test_p))

# CIFæ›²ç·šã®ä½œå›³
plot(cif_result, 
     main = "Cumulative Incidence of Recurrence by Risk Group",
     xlab = "Time (months)",
     ylab = "Cumulative incidence",
     xlim = c(0, 24),
     ylim = c(0, 1),
     col = c("#00BFC4", "#F8766D", "#C77CFF"),
     lty = 1,
     lwd = 2)
legend("topleft", 
       legend = c("Low risk", "Medium risk", "High risk"),
       col = c("#00BFC4", "#F8766D", "#C77CFF"),
       lty = 1,
       lwd = 2)

# 24ãƒ¶æœˆæ™‚ç‚¹ã®CIFå€¤
message("\n24-month cumulative incidence:")
for (group in c("Low", "Medium", "High")) {
  group_data <- test_data[test_data$risk_group == group, ]
  cif_24m <- sum(group_data$recur_2y == TRUE & group_data$time2y <= 24) / nrow(group_data)
  message(sprintf("  %s risk: %.1f%%", group, cif_24m * 100))
}

# 5. Fine-Grayãƒ¢ãƒ‡ãƒ«ï¼ˆç«¶åˆãƒªã‚¹ã‚¯å›å¸°ï¼‰
if (requireNamespace("riskRegression", quietly = TRUE)) {
  message("\n--- Fine-Gray Model ---")
  
  fg_model <- FGR(
    Hist(time2y, event_type) ~ risk_group,
    data = test_data,
    cause = 1
  )
  
  print(summary(fg_model))
}
```


```{r}
# ========================================================================
# å…¨ãƒ¢ãƒ‡ãƒ«ã®åŒ…æ‹¬çš„è©•ä¾¡ï¼ˆLASSOå®Œå…¨å¯¾å¿œç‰ˆï¼‰
# ========================================================================

message("\n========================================")
message("COMPREHENSIVE MODEL EVALUATION (FIXED)")
message("========================================\n")

# çµæœã‚’æ ¼ç´ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ 
comprehensive_results <- data.frame()

# å„ãƒ¢ãƒ‡ãƒ«ã‚’è©•ä¾¡
for (model_name in names(models)) {
  model <- models[[model_name]]
  
  if (!is.null(model)) {
    message(sprintf("\nEvaluating: %s", model_name))
    message(paste(rep("-", 40), collapse = ""))
    
    # çµæœè¡Œã‚’åˆæœŸåŒ–
    results_row <- data.frame(
      Model = model_name,
      stringsAsFactors = FALSE
    )
    
    # Train, Val, Testã®é †ã§è©•ä¾¡
    for (set_name in c("train", "val", "test")) {
      data <- split_data_fixed[[set_name]]
      
      if (!is.null(data)) {
        
        # ========== C-index ==========
        c_index <- tryCatch({
          # LASSOãƒ¢ãƒ‡ãƒ«ã®ç‰¹åˆ¥å‡¦ç†
          if (inherits(model, "lasso_cox") || 
              (inherits(model, "list") && !is.null(model$glmnet_model))) {
            
            # å¿…è¦ãªå¤‰æ•°ã®è¡Œåˆ—ã‚’ä½œæˆ
            X_test <- matrix(0, nrow = nrow(data), ncol = ncol(model$X))
            colnames(X_test) <- colnames(model$X)
            
            # å„å¤‰æ•°ã‚’ãƒãƒƒãƒ”ãƒ³ã‚°
            for (var in colnames(model$X)) {
              if (var %in% names(data)) {
                X_test[, var] <- as.numeric(data[[var]])
              } else if (grepl("TRUE$", var)) {
                # microVITRUE -> microVI
                base_var <- sub("TRUE$", "", var)
                if (base_var %in% names(data)) {
                  X_test[, var] <- as.numeric(data[[base_var]] == TRUE)
                }
              } else if (grepl("^stage_diag", var)) {
                # stage_diagBR1, stage_diagBR2
                if ("stage_diag" %in% names(data)) {
                  level <- sub("^stage_diag", "", var)
                  X_test[, var] <- as.numeric(data$stage_diag == level)
                }
              } else if (grepl("^liver_damage", var)) {
                if ("liver_damage" %in% names(data)) {
                  level <- sub("^liver_damage", "", var)
                  X_test[, var] <- as.numeric(data$liver_damage == level)
                }
              } else if (grepl("^child_pugh", var)) {
                if ("child_pugh" %in% names(data)) {
                  level <- sub("^child_pugh", "", var)
                  X_test[, var] <- as.numeric(data$child_pugh == level)
                }
              } else if (var == "fc_inf1" && "fc_inf" %in% names(data)) {
                X_test[, var] <- as.numeric(data$fc_inf == "1")
              } else if (var == "sm1" && "sm" %in% names(data)) {
                X_test[, var] <- as.numeric(data$sm == "1")
              }
            }
            
            # äºˆæ¸¬
            pred <- predict(model$glmnet_model, newx = X_test, 
                           s = model$lambda_min, type = "link")[, 1]
            
          # é€šå¸¸ã®Coxãƒ¢ãƒ‡ãƒ«
          } else if (inherits(model, "coxph")) {
            pred <- predict(model, newdata = data, type = "risk")
            
          # ãƒªã‚¹ãƒˆå‹ã§å†…éƒ¨ã«coxphã‚’æŒã¤å ´åˆ
          } else if (inherits(model, "list") && !is.null(model$model)) {
            pred <- predict(model$model, newdata = data, type = "risk")
            
          } else {
            pred <- NULL
          }
          
          if (!is.null(pred) && length(pred) > 0) {
            c_result <- survival::concordance(data$surv_obj ~ pred, reverse = TRUE)
            c_result$concordance
          } else {
            NA
          }
        }, error = function(e) {
          message(sprintf("    C-index error: %s", e$message))
          NA
        })
        
        # ========== AUC at 24 months ==========
        auc_24 <- tryCatch({
          # LASSOãƒ¢ãƒ‡ãƒ«ã®ç‰¹åˆ¥å‡¦ç†
          if (inherits(model, "lasso_cox") || 
              (inherits(model, "list") && !is.null(model$glmnet_model))) {
            
            # ä¸Šè¨˜ã¨åŒã˜è¡Œåˆ—ä½œæˆ
            X_test <- matrix(0, nrow = nrow(data), ncol = ncol(model$X))
            colnames(X_test) <- colnames(model$X)
            
            for (var in colnames(model$X)) {
              if (var %in% names(data)) {
                X_test[, var] <- as.numeric(data[[var]])
              } else if (grepl("TRUE$", var)) {
                base_var <- sub("TRUE$", "", var)
                if (base_var %in% names(data)) {
                  X_test[, var] <- as.numeric(data[[base_var]] == TRUE)
                }
              } else if (grepl("^stage_diag", var)) {
                if ("stage_diag" %in% names(data)) {
                  level <- sub("^stage_diag", "", var)
                  X_test[, var] <- as.numeric(data$stage_diag == level)
                }
              } else if (grepl("^liver_damage", var)) {
                if ("liver_damage" %in% names(data)) {
                  level <- sub("^liver_damage", "", var)
                  X_test[, var] <- as.numeric(data$liver_damage == level)
                }
              } else if (grepl("^child_pugh", var)) {
                if ("child_pugh" %in% names(data)) {
                  level <- sub("^child_pugh", "", var)
                  X_test[, var] <- as.numeric(data$child_pugh == level)
                }
              } else if (var == "fc_inf1" && "fc_inf" %in% names(data)) {
                X_test[, var] <- as.numeric(data$fc_inf == "1")
              } else if (var == "sm1" && "sm" %in% names(data)) {
                X_test[, var] <- as.numeric(data$sm == "1")
              }
            }
            
            risk_scores <- predict(model$glmnet_model, newx = X_test, 
                                 s = model$lambda_min, type = "link")[, 1]
            
          } else if (inherits(model, "coxph")) {
            risk_scores <- predict(model, newdata = data, type = "risk")
          } else if (inherits(model, "list") && !is.null(model$model)) {
            risk_scores <- predict(model$model, newdata = data, type = "risk")
          } else {
            risk_scores <- NULL
          }
          
          if (!is.null(risk_scores) && requireNamespace("pROC", quietly = TRUE)) {
            outcome_24m <- as.numeric(data$recur_2y == TRUE & data$time2y <= 24)
            if (sum(outcome_24m) > 0 && sum(outcome_24m) < length(outcome_24m)) {
              roc_obj <- pROC::roc(outcome_24m, risk_scores, quiet = TRUE)
              as.numeric(pROC::auc(roc_obj))
            } else {
              NA
            }
          } else {
            NA
          }
        }, error = function(e) {
          message(sprintf("    AUC error: %s", e$message))
          NA
        })
        
        # ========== Brier Score ==========
        brier <- tryCatch({
          # ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸäºˆæ¸¬ç¢ºç‡ã®è¨ˆç®—
          if (inherits(model, "lasso_cox") || 
              (inherits(model, "list") && !is.null(model$glmnet_model))) {
            
            # LASSOç”¨ã®è¡Œåˆ—ä½œæˆï¼ˆåŒä¸Šï¼‰
            X_test <- matrix(0, nrow = nrow(data), ncol = ncol(model$X))
            colnames(X_test) <- colnames(model$X)
            
            for (var in colnames(model$X)) {
              if (var %in% names(data)) {
                X_test[, var] <- as.numeric(data[[var]])
              } else if (grepl("TRUE$", var)) {
                base_var <- sub("TRUE$", "", var)
                if (base_var %in% names(data)) {
                  X_test[, var] <- as.numeric(data[[base_var]] == TRUE)
                }
              } else if (grepl("^stage_diag", var)) {
                if ("stage_diag" %in% names(data)) {
                  level <- sub("^stage_diag", "", var)
                  X_test[, var] <- as.numeric(data$stage_diag == level)
                }
              } else if (grepl("^liver_damage", var)) {
                if ("liver_damage" %in% names(data)) {
                  level <- sub("^liver_damage", "", var)
                  X_test[, var] <- as.numeric(data$liver_damage == level)
                }
              } else if (grepl("^child_pugh", var)) {
                if ("child_pugh" %in% names(data)) {
                  level <- sub("^child_pugh", "", var)
                  X_test[, var] <- as.numeric(data$child_pugh == level)
                }
              } else if (var == "fc_inf1" && "fc_inf" %in% names(data)) {
                X_test[, var] <- as.numeric(data$fc_inf == "1")
              } else if (var == "sm1" && "sm" %in% names(data)) {
                X_test[, var] <- as.numeric(data$sm == "1")
              }
            }
            
            lp <- predict(model$glmnet_model, newx = X_test, 
                         s = model$lambda_min, type = "link")[, 1]
            
            # ç°¡æ˜“çš„ãªäºˆæ¸¬ç¢ºç‡ï¼ˆãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ãƒã‚¶ãƒ¼ãƒ‰ãŒãªã„ãŸã‚è¿‘ä¼¼ï¼‰
            pred_prob <- 1 - exp(-exp(lp) * 0.3)  # 0.3ã¯ä»®ã®å€¤
            
          } else if (inherits(model, "coxph")) {
            lp <- predict(model, newdata = data, type = "lp")
            basehaz_df <- basehaz(model, centered = FALSE)
            time_idx <- which.min(abs(basehaz_df$time - 24))
            if (length(time_idx) == 0) time_idx <- nrow(basehaz_df)
            baseline_cumhaz <- basehaz_df$hazard[time_idx]
            pred_prob <- 1 - exp(-baseline_cumhaz * exp(lp))
            
          } else if (inherits(model, "list") && !is.null(model$model)) {
            lp <- predict(model$model, newdata = data, type = "lp")
            basehaz_df <- basehaz(model$model, centered = FALSE)
            time_idx <- which.min(abs(basehaz_df$time - 24))
            if (length(time_idx) == 0) time_idx <- nrow(basehaz_df)
            baseline_cumhaz <- basehaz_df$hazard[time_idx]
            pred_prob <- 1 - exp(-baseline_cumhaz * exp(lp))
            
          } else {
            pred_prob <- NULL
          }
          
          if (!is.null(pred_prob) && length(pred_prob) > 0) {
            event_occurred <- (data$recur_2y == TRUE) & (data$time2y <= 24)
            mean((pred_prob - as.numeric(event_occurred))^2, na.rm = TRUE)
          } else {
            NA
          }
        }, error = function(e) {
          message(sprintf("    Brier error: %s", e$message))
          NA
        })
        
        # çµæœã‚’æ ¼ç´
        col_prefix <- stringr::str_to_title(set_name)
        results_row[[paste0("C_index_", col_prefix)]] <- c_index
        results_row[[paste0("AUC_", col_prefix)]] <- auc_24
        results_row[[paste0("Brier_", col_prefix)]] <- brier
        
        message(sprintf("  %s: C-index=%.3f, AUC=%.3f, Brier=%.3f", 
                       col_prefix, 
                       ifelse(is.na(c_index), NA, c_index),
                       ifelse(is.na(auc_24), NA, auc_24),
                       ifelse(is.na(brier), NA, brier)))
      }
    }
    
    # OverfittingæŒ‡æ¨™
    results_row$Overfitting_CIndex <- results_row$C_index_Train - results_row$C_index_Test
    results_row$Overfitting_AUC <- results_row$AUC_Train - results_row$AUC_Test
    
    # è¡Œã‚’è¿½åŠ 
    comprehensive_results <- rbind(comprehensive_results, results_row)
  }
}

# Test C-indexã§ã‚½ãƒ¼ãƒˆ
comprehensive_results <- comprehensive_results[order(comprehensive_results$C_index_Test, 
                                                   decreasing = TRUE, 
                                                   na.last = TRUE), ]

# ä¿å­˜
write.csv(comprehensive_results, 
         file.path(paths$output_tables, "model_performance_complete.csv"),
         row.names = FALSE)

message("\nâœ… Evaluation complete - INCLUDING LASSO models!")
print(comprehensive_results)
```

