---
title: "05_model_builder"
author: "Takuto Yoshida"
date: "2025-11-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
################################################################################
# 05_model_builder.R - ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰å‡¦ç†
# 
# Description: 
#   å„ç¨®å¤‰æ•°é¸æŠæ‰‹æ³•ã«ã‚ˆã‚‹ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰
#   Stepwise, LASSO, RFE, å˜å¤‰é‡ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°, äº‹å‰å®šç¾©ãƒ¢ãƒ‡ãƒ«
#   Coxæ¯”ä¾‹ãƒã‚¶ãƒ¼ãƒ‰ãƒ¢ãƒ‡ãƒ«ãƒ™ãƒ¼ã‚¹
#
# Author: Takuto Yoshida
# Date: 2024-11-07
################################################################################

# ========================================================================
# 1. ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰ã®æº–å‚™
# ========================================================================

#' ãƒ¢ãƒ‡ãƒ«ç”¨ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
#' @param df ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ 
#' @param outcome_time æ™‚é–“å¤‰æ•°å
#' @param outcome_event ã‚¤ãƒ™ãƒ³ãƒˆå¤‰æ•°å
#' @param variables ä½¿ç”¨ã™ã‚‹å¤‰æ•°ãƒªã‚¹ãƒˆ
#' @param config è¨­å®šãƒªã‚¹ãƒˆ
#' @return ãƒ¢ãƒ‡ãƒ«ç”¨ãƒ‡ãƒ¼ã‚¿
prepare_model_data <- function(df, 
                              outcome_time = "time2y",
                              outcome_event = "recur_2y",
                              variables = NULL,
                              config = NULL) {
  
  message("\nğŸ“Š Preparing model data...")
  
  # ã‚¢ã‚¦ãƒˆã‚«ãƒ ã®ç¢ºèªï¼ˆæ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ç¶­æŒï¼‰
  if (!outcome_time %in% names(df)) {
    if ("rfs_months" %in% names(df)) {
      df$time2y <- pmin(df$rfs_months, 24, na.rm = FALSE)
      message("  Created time2y from rfs_months")
    } else {
      stop(sprintf("Time variable '%s' not found", outcome_time))
    }
  }
  
  if (!outcome_event %in% names(df)) {
    if (all(c("recur_tf", "rfs_months") %in% names(df))) {
      df$recur_2y <- (df$recur_tf == TRUE | df$recur_tf == "TRUE" | df$recur_tf == 1) & 
                     (df$rfs_months <= 24)
      message("  Created recur_2y from recur_tf and rfs_months")
    } else {
      stop(sprintf("Event variable '%s' not found", outcome_event))
    }
  }
  
  # ===== æ–°è¦è¿½åŠ ï¼šæ¬ æå€¤å‡¦ç†ã‚’å…ˆã«å®Ÿè¡Œ =====
  # handle_missing_valuesã‚’å‘¼ã³å‡ºã—ã¦æ¬ æå€¤ã‚’è£œå®Œ
  df_imputed <- handle_missing_values(df, config = config, method = "median")
  
  # å¤‰æ•°é¸æŠ
  if (!is.null(variables) && length(variables) > 0) {
    # æŒ‡å®šã•ã‚ŒãŸå¤‰æ•°ã®ã¿ã‚’ä½¿ç”¨
    use_vars <- intersect(variables, names(df_imputed))
    missing_vars <- setdiff(variables, names(df_imputed))
    
    message(sprintf("  Using %d specified variables (missing: %d)", 
                   length(use_vars), length(missing_vars)))
    
    # å¿…è¦ãªåˆ—ã®ã¿é¸æŠ
    model_data <- df_imputed[, c(outcome_time, outcome_event, use_vars), drop = FALSE]
    
  } else {
    # æ—¢å­˜ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç†
    numeric_vars <- names(df_imputed)[sapply(df_imputed, is.numeric)]
    factor_vars <- names(df_imputed)[sapply(df_imputed, is.factor)]
    
    exclude_patterns <- c("id", "num", "date", "time2y", "recur_2y", 
                         "os_months", "rfs_months", "vital", "death")
    
    use_vars <- setdiff(
      c(numeric_vars, factor_vars),
      grep(paste(exclude_patterns, collapse = "|"), 
           c(numeric_vars, factor_vars), 
           value = TRUE, ignore.case = TRUE)
    )
    
    model_data <- df_imputed[, c(outcome_time, outcome_event, use_vars), drop = FALSE]
  }
  
  # ===== ä¿®æ­£ï¼šna.omitã®ä»£ã‚ã‚Šã«æ®‹å­˜æ¬ æå€¤ã®ã¿ãƒã‚§ãƒƒã‚¯ =====
  n_before <- nrow(model_data)
  n_missing_rows <- sum(!complete.cases(model_data))
  
  if (n_missing_rows > 0) {
    # ã¾ã æ¬ æãŒã‚ã‚‹å ´åˆã®ã¿é™¤å¤–ï¼ˆã»ã¼ãªã„ã¯ãšï¼‰
    model_data <- na.omit(model_data)
    n_after <- nrow(model_data)
    message(sprintf("  Removed %d rows with remaining missing values", 
                   n_before - n_after))
  } else {
    message("  No rows removed (all data complete after imputation)")
    n_after <- n_before
  }
  
  # Survivalã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ
  model_data$surv_obj <- survival::Surv(
    time = model_data[[outcome_time]],
    event = as.numeric(model_data[[outcome_event]])
  )
  
  # çµæœã®å±æ€§
  attr(model_data, "outcome_time") <- outcome_time
  attr(model_data, "outcome_event") <- outcome_event
  attr(model_data, "variables") <- use_vars
  attr(model_data, "n_complete") <- n_after
  
  message(sprintf("  Final dataset: %d rows Ã— %d variables", 
                 nrow(model_data), length(use_vars)))
  
  return(model_data)
}

# ========================================================================
# 2. Stepwise Selection (Forward/Backward)
# ========================================================================

#' Stepwiseå¤‰æ•°é¸æŠã«ã‚ˆã‚‹Coxãƒ¢ãƒ‡ãƒ«
#' @param train_data è¨“ç·´ãƒ‡ãƒ¼ã‚¿
#' @param direction æ–¹å‘ï¼ˆ"forward", "backward", "both"ï¼‰
#' @param criterion åŸºæº–ï¼ˆ"AIC", "BIC"ï¼‰
#' @param trace çµŒéè¡¨ç¤º
#' @return ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
build_stepwise_model <- function(train_data,
                                direction = "both",
                                criterion = "AIC",
                                trace = FALSE) {
  
  message(sprintf("\nğŸ”„ Building Stepwise Cox model (%s, %s)...", 
                 direction, criterion))
  
  # å¤‰æ•°ãƒªã‚¹ãƒˆ
  variables <- attr(train_data, "variables")
  
  # ãƒ•ã‚©ãƒ¼ãƒŸãƒ¥ãƒ©ã®ä½œæˆ
  if (direction == "forward") {
    # Null model ã‹ã‚‰é–‹å§‹
    null_formula <- as.formula("surv_obj ~ 1")
    full_formula <- as.formula(paste("surv_obj ~", paste(variables, collapse = " + ")))
    
    null_model <- survival::coxph(null_formula, data = train_data)
    
    # Stepwise forward
    k <- ifelse(criterion == "BIC", log(nrow(train_data)), 2)
    
    final_model <- MASS::stepAIC(
      null_model,
      scope = list(lower = null_formula, upper = full_formula),
      direction = "forward",
      k = k,
      trace = trace
    )
    
  } else if (direction == "backward") {
    # Full model ã‹ã‚‰é–‹å§‹
    full_formula <- as.formula(paste("surv_obj ~", paste(variables, collapse = " + ")))
    
    full_model <- survival::coxph(full_formula, data = train_data)
    
    # Stepwise backward
    k <- ifelse(criterion == "BIC", log(nrow(train_data)), 2)
    
    final_model <- MASS::stepAIC(
      full_model,
      direction = "backward",
      k = k,
      trace = trace
    )
    
  } else {  # both
    # Null model ã‹ã‚‰é–‹å§‹
    null_formula <- as.formula("surv_obj ~ 1")
    full_formula <- as.formula(paste("surv_obj ~", paste(variables, collapse = " + ")))
    
    null_model <- survival::coxph(null_formula, data = train_data)
    
    # Stepwise both
    k <- ifelse(criterion == "BIC", log(nrow(train_data)), 2)
    
    final_model <- MASS::stepAIC(
      null_model,
      scope = list(lower = null_formula, upper = full_formula),
      direction = "both",
      k = k,
      trace = trace
    )
  }
  
  # é¸æŠã•ã‚ŒãŸå¤‰æ•°
  selected_vars <- names(coef(final_model))
  message(sprintf("  Selected %d variables: %s", 
                 length(selected_vars),
                 paste(head(selected_vars, 5), collapse = ", ")))
  
  if (length(selected_vars) > 5) {
    message(sprintf("    ... and %d more", length(selected_vars) - 5))
  }
  
  # ãƒ¢ãƒ‡ãƒ«æƒ…å ±ã‚’å±æ€§ã¨ã—ã¦è¿½åŠ 
  attr(final_model, "method") <- paste0("stepwise_", direction, "_", tolower(criterion))
  attr(final_model, "selected_vars") <- selected_vars
  attr(final_model, "n_vars") <- length(selected_vars)
  
  return(final_model)
}

# ========================================================================
# 3. LASSO Regression
# ========================================================================

#' LASSO Coxå›å¸°ãƒ¢ãƒ‡ãƒ«
#' @param train_data è¨“ç·´ãƒ‡ãƒ¼ã‚¿
#' @param alpha Elastic Netãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆ1=LASSO, 0=Ridgeï¼‰
#' @param standardize æ¨™æº–åŒ–ã™ã‚‹ã‹
#' @param nfolds CVåˆ†å‰²æ•°
#' @param type.measure è©•ä¾¡æŒ‡æ¨™
#' @return ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
build_lasso_model <- function(train_data,
                             alpha = 1.0,
                             standardize = TRUE,
                             nfolds = 5,
                             type.measure = "deviance") {
  
  message(sprintf("\nğŸ¯ Building LASSO Cox model (alpha=%.1f)...", alpha))
  
  # å¤‰æ•°ãƒªã‚¹ãƒˆ
  variables <- attr(train_data, "variables")
  
  if (any(train_data$surv_obj[, "time"] <= 0)) {
    train_data$surv_obj[, "time"][train_data$surv_obj[, "time"] <= 0] <- 0.1
    message("  Fixed zero/negative time values")
  }
  
  # è¡Œåˆ—å½¢å¼ã«å¤‰æ›
  X <- model.matrix(~ . - 1, data = train_data[, variables, drop = FALSE])
  
  # Survivalã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
  y <- train_data$surv_obj
  
  # Cross-validation
  # lambdaå€™è£œã®è‡ªå‹•ç”Ÿæˆã€å†…éƒ¨cvã€å„lambdaå€™è£œã®è©•ä¾¡ã€æœ€çµ‚lambdaã®æ±ºå®šã‚’ã‚„ã£ã¦ãã‚Œã‚‹
  set.seed(123)  # å†ç¾æ€§ã®ãŸã‚
  cv_fit <- glmnet::cv.glmnet(
    x = X,
    y = y,
    family = "cox",
    alpha = alpha,
    standardize = standardize,
    nfolds = nfolds,
    type.measure = type.measure
  )
  
  # æœ€é©ãªlambdaã§ã®ãƒ¢ãƒ‡ãƒ«
  final_model <- glmnet::glmnet(
    x = X,
    y = y,
    family = "cox",
    alpha = alpha,
    lambda = cv_fit$lambda.min,
    standardize = standardize
  )
  
  # ä¿‚æ•°ã®å–å¾—
  coef_matrix <- as.matrix(coef(final_model))
  selected_vars <- rownames(coef_matrix)[coef_matrix[, 1] != 0]
  
  message(sprintf("  Optimal lambda: %.4f", cv_fit$lambda.min))
  message(sprintf("  Selected %d variables: %s", 
                 length(selected_vars),
                 paste(head(selected_vars, 5), collapse = ", ")))
  
  if (length(selected_vars) > 5) {
    message(sprintf("    ... and %d more", length(selected_vars) - 5))
  }
  
  # çµæœã®æ§‹é€ åŒ–
  result <- list(
    glmnet_model = final_model,
    cv_fit = cv_fit,
    selected_vars = selected_vars,
    lambda_min = cv_fit$lambda.min,
    lambda_1se = cv_fit$lambda.1se,
    X = X,
    y = y
  )
  
  attr(result, "method") <- paste0("lasso_alpha", alpha)
  attr(result, "selected_vars") <- selected_vars
  attr(result, "n_vars") <- length(selected_vars)
  
  class(result) <- c("lasso_cox", "list")
  
  return(result)
}

# ========================================================================
# 4. LASSO with Constraint (å¤‰æ•°æ•°åˆ¶ç´„ç‰ˆ)
# ========================================================================

#' å¤‰æ•°æ•°åˆ¶ç´„ä»˜ãLASSO
#' @param train_data è¨“ç·´ãƒ‡ãƒ¼ã‚¿
#' @param target_nvars ç›®æ¨™å¤‰æ•°æ•°
#' @param max_nvars æœ€å¤§å¤‰æ•°æ•°
#' @return ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
build_lasso_constrained <- function(train_data,
                                   target_nvars = 5,
                                   max_nvars = 6) {
  
  message(sprintf("\nğŸ¯ Building constrained LASSO (target=%d vars)...", 
                 target_nvars))
  
  # å¤‰æ•°ãƒªã‚¹ãƒˆ
  variables <- attr(train_data, "variables")
  
  # è¡Œåˆ—å½¢å¼ã«å¤‰æ›
  X <- model.matrix(~ . - 1, data = train_data[, variables, drop = FALSE])
  y <- train_data$surv_obj
  
  # Lambdaç³»åˆ—ã§å®Œå…¨ãƒ‘ã‚¹ã‚’è¨ˆç®—
  full_fit <- glmnet::glmnet(
    x = X,
    y = y,
    family = "cox",
    alpha = 1,
    standardize = TRUE
  )
  
  # å„lambdaã§ã®å¤‰æ•°æ•°ã‚’ç¢ºèª
  n_vars <- apply(coef(full_fit), 2, function(x) sum(x != 0))
  
  # ç›®æ¨™å¤‰æ•°æ•°ã«æœ€ã‚‚è¿‘ã„lambdaã‚’é¸æŠ
  target_idx <- which.min(abs(n_vars - target_nvars))
  
  # å¤‰æ•°æ•°ãŒç¯„å›²å†…ã®lambdaã‚’æ¢ã™
  valid_idx <- which(n_vars >= target_nvars & n_vars <= max_nvars)
  
  if (length(valid_idx) > 0) {
    # Cross-validationã‚¹ã‚³ã‚¢ã§æœ€è‰¯ã‚’é¸æŠ
    cv_fit <- glmnet::cv.glmnet(
      x = X,
      y = y,
      family = "cox",
      alpha = 1,
      lambda = full_fit$lambda[valid_idx],
      standardize = TRUE,
      nfolds = 5
    )
    
    optimal_lambda <- cv_fit$lambda.min
  } else {
    # ç¯„å›²å†…ãŒãªã„å ´åˆã¯æœ€ã‚‚è¿‘ã„ã‚‚ã®ã‚’ä½¿ç”¨
    optimal_lambda <- full_fit$lambda[target_idx]
  }
  
  # æœ€çµ‚ãƒ¢ãƒ‡ãƒ«
  final_model <- glmnet::glmnet(
    x = X,
    y = y,
    family = "cox",
    alpha = 1,
    lambda = optimal_lambda,
    standardize = TRUE
  )
  
  # ä¿‚æ•°ã®å–å¾—
  coef_matrix <- as.matrix(coef(final_model))
  selected_vars <- rownames(coef_matrix)[coef_matrix[, 1] != 0]
  
  message(sprintf("  Selected %d variables: %s", 
                 length(selected_vars),
                 paste(selected_vars, collapse = ", ")))
  
  # çµæœã®æ§‹é€ åŒ–
  result <- list(
    glmnet_model = final_model,
    selected_vars = selected_vars,
    lambda = optimal_lambda,
    X = X,
    y = y
  )
  
  attr(result, "method") <- "lasso_constrained"
  attr(result, "selected_vars") <- selected_vars
  attr(result, "n_vars") <- length(selected_vars)
  attr(result, "target_nvars") <- target_nvars
  
  class(result) <- c("lasso_cox", "list")
  
  return(result)
}

# ========================================================================
# 5. Univariate Screening
# ========================================================================

#' å˜å¤‰é‡ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
#' @param train_data è¨“ç·´ãƒ‡ãƒ¼ã‚¿
#' @param p_threshold på€¤ã®é–¾å€¤
#' @param stop_p åœæ­¢på€¤
#' @param max_vars æœ€å¤§å¤‰æ•°æ•°
#' @return ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
build_univariate_screen_model <- function(train_data,
                                         p_threshold = 0.10,
                                         stop_p = 0.05,
                                         max_vars = 20) {
  
  message(sprintf("\nğŸ” Building Univariate Screening model (p<%.2f)...", 
                 p_threshold))
  
  variables <- attr(train_data, "variables")
  
  # å„å¤‰æ•°ã®å˜å¤‰é‡è§£æ
  univariate_results <- data.frame(
    variable = character(),
    original_var = character(),  # â† è¿½åŠ ï¼šå…ƒã®å¤‰æ•°åã‚’ä¿æŒ
    coef = numeric(),
    hr = numeric(),
    se = numeric(),
    z = numeric(),
    p_value = numeric(),
    stringsAsFactors = FALSE
  )
  
  for (var in variables) {
    formula <- as.formula(paste("surv_obj ~", var))
    
    tryCatch({
      uni_model <- survival::coxph(formula, data = train_data)
      summary_uni <- summary(uni_model)
      coef_info <- summary_uni$coefficients
      
      if (nrow(coef_info) > 0) {
        for (i in 1:nrow(coef_info)) {
          univariate_results <- rbind(
            univariate_results,
            data.frame(
              variable = rownames(coef_info)[i],
              original_var = var,  # â† è¿½åŠ ï¼šå…ƒã®å¤‰æ•°åã‚’ä¿æŒ
              coef = coef_info[i, "coef"],
              hr = coef_info[i, "exp(coef)"],
              se = coef_info[i, "se(coef)"],
              z = coef_info[i, "z"],
              p_value = coef_info[i, "Pr(>|z|)"],
              stringsAsFactors = FALSE
            )
          )
        }
      }
    }, error = function(e) {
      # ã‚¨ãƒ©ãƒ¼ã¯é™ã‹ã«å‡¦ç†
    })
  }
  
  # på€¤ã§ã‚½ãƒ¼ãƒˆ
  univariate_results <- univariate_results[order(univariate_results$p_value), ]
  
  # ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
  selected_results <- univariate_results[univariate_results$p_value < p_threshold, ]
  
  if (nrow(selected_results) > max_vars) {
    selected_results <- selected_results[1:max_vars, ]
  }
  
  # â† ä¿®æ­£ï¼šå…ƒã®å¤‰æ•°åã‚’ä½¿ç”¨ï¼ˆstage_diagBR2ã§ã¯ãªãstage_diagï¼‰
  selected_vars <- unique(selected_results$original_var)
  
  message(sprintf("  Selected %d variables (p < %.2f):", 
                 length(selected_vars), p_threshold))
  
  # ä¸Šä½5å¤‰æ•°ã®på€¤ã‚’è¡¨ç¤º
  top_vars <- head(selected_results, 5)
  for (i in 1:nrow(top_vars)) {
    message(sprintf("    %s: p=%.4f, HR=%.2f", 
                   top_vars$variable[i], 
                   top_vars$p_value[i],
                   top_vars$hr[i]))
  }
  
  # å¤šå¤‰é‡ãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰
  if (length(selected_vars) > 0) {
    multi_formula <- as.formula(paste("surv_obj ~", 
                                     paste(selected_vars, collapse = " + ")))
    final_model <- survival::coxph(multi_formula, data = train_data)
  } else {
    warning("No variables selected in univariate screening")
    final_model <- NULL
  }
  
  # çµæœã®æ§‹é€ åŒ–
  result <- list(
    model = final_model,
    univariate_results = univariate_results,
    selected_results = selected_results,
    selected_vars = selected_vars,
    p_threshold = p_threshold
  )
  
  attr(result, "method") <- "univariate_screen"
  attr(result, "selected_vars") <- selected_vars
  attr(result, "n_vars") <- length(selected_vars)
  
  class(result) <- c("univariate_cox", "list")
  
  return(result)
}

# ========================================================================
# 6. Recursive Feature Elimination (RFE)
# ========================================================================

#' RFEã«ã‚ˆã‚‹å¤‰æ•°é¸æŠ
#' @param train_data è¨“ç·´ãƒ‡ãƒ¼ã‚¿
#' @param min_vars æœ€å°å¤‰æ•°æ•°
#' @param step_size ä¸€åº¦ã«å‰Šé™¤ã™ã‚‹å¤‰æ•°æ•°
#' @return ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
build_rfe_model <- function(train_data,
                           min_vars = 5,
                           step_size = 1) {
  
  message("\nâ™»ï¸ Building RFE Cox model...")
  
  variables <- attr(train_data, "variables")
  current_vars <- variables
  
  # RFEãƒ—ãƒ­ã‚»ã‚¹
  rfe_history <- list()
  best_c_index <- 0
  best_vars <- NULL
  
  while (length(current_vars) >= min_vars) {
    # ç¾åœ¨ã®å¤‰æ•°ã‚»ãƒƒãƒˆã§ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰
    formula <- as.formula(paste("surv_obj ~", paste(current_vars, collapse = " + ")))
    
    tryCatch({
      model <- survival::coxph(formula, data = train_data)
      
      # C-indexã®è¨ˆç®—
      c_index <- survival::concordance(model)$concordance
      
      # å±¥æ­´ã«ä¿å­˜
      rfe_history[[length(rfe_history) + 1]] <- list(
        n_vars = length(current_vars),
        c_index = c_index,
        vars = current_vars
      )
      
      # ãƒ™ã‚¹ãƒˆãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
      if (c_index > best_c_index) {
        best_c_index <- c_index
        best_vars <- current_vars
      }
      
      # å¤‰æ•°é‡è¦åº¦ï¼ˆçµ¶å¯¾å€¤ã®zå€¤ï¼‰
      summary_model <- summary(model)
      importance <- abs(summary_model$coefficients[, "z"])
      
      # æœ€ã‚‚é‡è¦åº¦ã®ä½ã„å¤‰æ•°ã‚’å‰Šé™¤
      if (length(current_vars) > min_vars) {
        # å¤‰æ•°åã®å–å¾—ï¼ˆå› å­ã®å ´åˆã®å‡¦ç†ï¼‰
        var_importance <- sapply(current_vars, function(v) {
          idx <- grep(paste0("^", v), names(importance))
          if (length(idx) > 0) {
            mean(importance[idx])
          } else {
            0
          }
        })
        
        # å‰Šé™¤ã™ã‚‹å¤‰æ•°
        n_remove <- min(step_size, length(current_vars) - min_vars)
        remove_vars <- names(sort(var_importance))[1:n_remove]
        current_vars <- setdiff(current_vars, remove_vars)
        
        message(sprintf("  Variables: %d, C-index: %.3f", 
                       length(current_vars), c_index))
      } else {
        break
      }
      
    }, error = function(e) {
      message(sprintf("    Warning: Failed with %d variables", length(current_vars)))
      break
    })
  }
  
  # æœ€è‰¯ã®å¤‰æ•°ã‚»ãƒƒãƒˆã§ãƒ¢ãƒ‡ãƒ«å†æ§‹ç¯‰
  if (!is.null(best_vars)) {
    final_formula <- as.formula(paste("surv_obj ~", paste(best_vars, collapse = " + ")))
    final_model <- survival::coxph(final_formula, data = train_data)
    
    message(sprintf("  Best model: %d variables, C-index: %.3f", 
                   length(best_vars), best_c_index))
    message(sprintf("  Selected: %s", 
                   paste(head(best_vars, 5), collapse = ", ")))
    
    if (length(best_vars) > 5) {
      message(sprintf("    ... and %d more", length(best_vars) - 5))
    }
  } else {
    final_model <- NULL
    best_vars <- character()
  }
  
  # çµæœã®æ§‹é€ åŒ–
  result <- list(
    model = final_model,
    selected_vars = best_vars,
    best_c_index = best_c_index,
    rfe_history = rfe_history
  )
  
  attr(result, "method") <- "rfe"
  attr(result, "selected_vars") <- best_vars
  attr(result, "n_vars") <- length(best_vars)
  
  class(result) <- c("rfe_cox", "list")
  
  return(result)
}

# ========================================================================
# 7. Pre-defined Model
# ========================================================================

#' äº‹å‰å®šç¾©å¤‰æ•°ã«ã‚ˆã‚‹ãƒ¢ãƒ‡ãƒ«
#' @param train_data è¨“ç·´ãƒ‡ãƒ¼ã‚¿
#' @param predefined_vars äº‹å‰å®šç¾©å¤‰æ•°ãƒªã‚¹ãƒˆ
#' @return ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
build_predefined_model <- function(train_data,
                                  predefined_vars = NULL) {
  
  message("\nğŸ“Œ Building Pre-defined Cox model...")
  
  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¤‰æ•°ï¼ˆè‡¨åºŠçš„ã«é‡è¦ãªå¤‰æ•°ï¼‰
  if (is.null(predefined_vars)) {
    predefined_vars <- c("age", "sex", "ALBIscore", "stage_diag", "t", "n", "m")
  }
  
  # åˆ©ç”¨å¯èƒ½ãªå¤‰æ•°ã®ã¿é¸æŠ
  available_vars <- intersect(predefined_vars, names(train_data))
  missing_vars <- setdiff(predefined_vars, names(train_data))
  
  if (length(missing_vars) > 0) {
    message(sprintf("  Warning: %d predefined variables not found: %s",
                   length(missing_vars),
                   paste(missing_vars, collapse = ", ")))
  }
  
  if (length(available_vars) == 0) {
    stop("No predefined variables found in data")
  }
  
  message(sprintf("  Using %d variables: %s", 
                 length(available_vars),
                 paste(available_vars, collapse = ", ")))
  
  # ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰
  formula <- as.formula(paste("surv_obj ~", paste(available_vars, collapse = " + ")))
  final_model <- survival::coxph(formula, data = train_data)
  
  # çµæœã®å±æ€§
  attr(final_model, "method") <- "predefined"
  attr(final_model, "selected_vars") <- available_vars
  attr(final_model, "n_vars") <- length(available_vars)
  
  return(final_model)
}

# ========================================================================
# 8. çµ±åˆãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰é–¢æ•°
# ========================================================================

#' å…¨ãƒ¢ãƒ‡ãƒ«ã‚’ä¸€æ‹¬æ§‹ç¯‰
#' @param split_data åˆ†å‰²ãƒ‡ãƒ¼ã‚¿
#' @param config è¨­å®šãƒªã‚¹ãƒˆ
#' @param variables å¤‰æ•°å®šç¾©ãƒªã‚¹ãƒˆ
#' @return ãƒ¢ãƒ‡ãƒ«ãƒªã‚¹ãƒˆ
build_all_models <- function(split_data, 
                            config = NULL, 
                            variables = NULL,
                            variable_set_name = "postop_pathology_custom") {  # â† è¿½åŠ 
  
  message("\n========================================")
  message("Building All Models")
  message(sprintf("Using variable set: %s", variable_set_name))  # â† è¿½åŠ 
  message("========================================")
  
  # ===== è¿½åŠ : YAMLã‹ã‚‰å¤‰æ•°ã‚»ãƒƒãƒˆã‚’å–å¾— =====
  candidate_vars <- NULL
  if (!is.null(variables) && !is.null(variables$variable_sets[[variable_set_name]])) {
    candidate_vars <- variables$variable_sets[[variable_set_name]]
    message(sprintf("  Loaded %d variables from '%s'", 
                   length(candidate_vars), variable_set_name))
  }
  
  # è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ï¼ˆä¿®æ­£: candidate_varsã‚’æ¸¡ã™ï¼‰
  train_data <- prepare_model_data(
    split_data$train,
    outcome_time = "time2y",
    outcome_event = "recur_2y",
    variables = candidate_vars,  # â† è¿½åŠ : YAMLã®å¤‰æ•°ã‚’æ¸¡ã™
    config = config
  )
  # ãƒ¢ãƒ‡ãƒ«ãƒªã‚¹ãƒˆ
  models <- list()
  
  # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ¢ãƒ‡ãƒ«ã®å–å¾—
  if (!is.null(config) && !is.null(config$models$active)) {
    active_models <- config$models$active
  } else {
    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    active_models <- c(
      "m1_stepaic_forward",
      "m2_stepaic_backward", 
      "m3_stepbic_forward",
      "m4_stepbic_backward",
      "m5_univariate_screen",
      "m6_rfe",
      "m7_lasso",
      "m7k_lasso_constrained",
      "m8_predefined"
    )
  }
  
  # å„ãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰
  for (model_name in active_models) {
    
    message(sprintf("\n--- Model: %s ---", model_name))
    
    tryCatch({
      
      if (model_name == "m1_stepaic_forward") {
        models[[model_name]] <- build_stepwise_model(
          train_data, 
          direction = "forward", 
          criterion = "AIC"
        )
        
      } else if (model_name == "m2_stepaic_backward") {
        models[[model_name]] <- build_stepwise_model(
          train_data, 
          direction = "backward", 
          criterion = "AIC"
        )
        
      } else if (model_name == "m3_stepbic_forward") {
        models[[model_name]] <- build_stepwise_model(
          train_data, 
          direction = "forward", 
          criterion = "BIC"
        )
        
      } else if (model_name == "m4_stepbic_backward") {
        models[[model_name]] <- build_stepwise_model(
          train_data, 
          direction = "backward", 
          criterion = "BIC"
        )
        
      } else if (model_name == "m5_univariate_screen") {
        p_threshold <- 0.10
        if (!is.null(config$models$settings$univariate_screen$p_threshold)) {
          p_threshold <- config$models$settings$univariate_screen$p_threshold
        }
        
        models[[model_name]] <- build_univariate_screen_model(
          train_data,
          p_threshold = p_threshold
        )
        
      } else if (model_name == "m6_rfe") {
        min_vars <- 5
        if (!is.null(config$models$settings$rfe$min_vars)) {
          min_vars <- config$models$settings$rfe$min_vars
        }
        
        models[[model_name]] <- build_rfe_model(
          train_data,
          min_vars = min_vars
        )
        
      } else if (model_name == "m7_lasso") {
        models[[model_name]] <- build_lasso_model(train_data)
        
      } else if (model_name == "m7k_lasso_constrained") {
        target_vars <- c(4, 6)
        if (!is.null(config$models$settings$lasso_constrained$target_variables)) {
          target_vars <- config$models$settings$lasso_constrained$target_variables
        }
        
        models[[model_name]] <- build_lasso_constrained(
          train_data,
          target_nvars = target_vars[1],
          max_nvars = target_vars[2]
        )
        
      } else if (model_name == "m8_predefined") {
        predefined_vars <- NULL
        if (!is.null(config$models$settings$predefined$variables)) {
          predefined_vars <- config$models$settings$predefined$variables
        }
        
        models[[model_name]] <- build_predefined_model(
          train_data,
          predefined_vars = predefined_vars
        )
        
      } else {
        message(sprintf("  Unknown model: %s", model_name))
      }
      
    }, error = function(e) {
      message(sprintf("  âŒ Error building %s: %s", model_name, e$message))
      models[[model_name]] <- NULL
    })
  }
  
  # ã‚µãƒãƒªãƒ¼
  message("\nğŸ“Š Model Building Summary:")
  
  for (model_name in names(models)) {
    if (!is.null(models[[model_name]])) {
      n_vars <- attr(models[[model_name]], "n_vars")
      if (is.null(n_vars)) {
        # coxphã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆ
        if ("coefficients" %in% names(models[[model_name]])) {
          n_vars <- length(coef(models[[model_name]]))
        }
      }
      message(sprintf("  %s: %d variables", model_name, n_vars))
    } else {
      message(sprintf("  %s: Failed", model_name))
    }
  }
  
  message("\nâœ… Model building completed!")
  message("========================================\n")
  
  # çµæœã®å±æ€§
  attr(models, "train_data") <- train_data
  attr(models, "split_data") <- split_data
  attr(models, "config") <- config
  
  return(models)
}

# ========================================================================
# 9. ãƒ¢ãƒ‡ãƒ«ã®ä¿å­˜ã¨èª­ã¿è¾¼ã¿
# ========================================================================

#' ãƒ¢ãƒ‡ãƒ«ã‚’ä¿å­˜
#' @param models ãƒ¢ãƒ‡ãƒ«ãƒªã‚¹ãƒˆ
#' @param file_path ä¿å­˜å…ˆãƒ‘ã‚¹
save_models <- function(models, file_path) {
  
  # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
  dir_path <- dirname(file_path)
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE, showWarnings = FALSE)
  }
  
  saveRDS(models, file = file_path)
  message(sprintf("  âœ“ Models saved to: %s", file_path))
}

#' ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿
#' @param file_path ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
#' @return ãƒ¢ãƒ‡ãƒ«ãƒªã‚¹ãƒˆ
load_models <- function(file_path) {
  
  if (!file.exists(file_path)) {
    stop(sprintf("Model file not found: %s", file_path))
  }
  
  models <- readRDS(file_path)
  message(sprintf("  âœ“ Models loaded from: %s", file_path))
  
  return(models)
}
```

